{% if is_htmx %}
{% extends "partials/content_only.html" %}
{% else %}
{% extends "base.html" %}
{% endif %}

{% block title %}Template Editor - FlakeBench{% endblock %}

{% block content %}
<div x-data="testConfiguration()" x-cloak>
    <!-- Initial load state (prevents "defaults then fill in later" flicker) -->
    <div x-show="isInitializing" class="card">
        <div class="flex items-center gap-3">
            <span class="loading-spinner"></span>
            <div>
                <div class="font-semibold">Loading configuration…</div>
                <div class="text-sm text-gray-600">Applying template and fetching warehouses</div>
            </div>
        </div>
    </div>

    <div x-show="!isInitializing">
    <div class="card">
        <div
            class="card-title"
            x-text="isReadOnly ? 'Template Details' : (mode === 'edit' ? 'Edit Template' : 'New Template')"
        ></div>
        <p x-show="!hasResults">Design a test configuration template. Templates can be run multiple times to compare results.</p>

        <div x-show="error" class="alert alert-error mt-4">
            <strong>Unable to load Snowflake data.</strong>
            <span x-text="error"></span>
            <div class="mt-2 text-sm">
                If this looks like a Snowflake connectivity issue, connect to VPN / allowlist your IP and refresh.
            </div>
        </div>
        
        <div x-show="loadedTemplate && !hasResults && !isReadOnly" class="alert alert-success mt-4">
            <strong>Editing Template:</strong> <span x-text="loadedTemplate?.template_name"></span>
        </div>

        <div x-show="loadedTemplate && isReadOnly" class="alert alert-info mt-4">
            <strong>Viewing Template:</strong> <span x-text="loadedTemplate?.template_name"></span>
        </div>
        
        <div x-show="hasResults" class="alert alert-warning mt-4">
            <strong>⚠️ Template has test results</strong><br>
            This template has been used <span x-text="loadedTemplate?.usage_count"></span> time(s) and can no longer be edited. 
            You can <strong>copy</strong> it to create an editable version or <strong>delete</strong> it (which will remove all test results).
        </div>

        <!-- Results warehouse guardrail -->
        <div
            x-show="!hasResults && resultsWarehouse && config.warehouse_name && String(config.warehouse_name).trim().toUpperCase() === resultsWarehouse"
            class="alert alert-warning mt-4"
        >
            <strong>⚠️ Execution warehouse cannot be your results warehouse</strong><br>
            This template is currently set to run on <code x-text="config.warehouse_name"></code>, which matches your results warehouse (<code x-text="resultsWarehouse"></code>).
            Please choose a different warehouse before saving or running.
        </div>
    </div>

    <form @submit.prevent="submitTest" :class="{ 'read-only-form': isReadOnly }">
        <fieldset :disabled="isSaving || aiPrepLoading || saveAndPrepareLoading || isReadOnly">
        <!-- Template Metadata Section (moved to top for better visibility) -->
        <div class="card">
            <div class="card-title">Template Metadata</div>
            
            <div class="form-group">
                <label class="form-label">Template Name *</label>
                <input type="text" class="form-input" x-model="config.template_name" placeholder="e.g., Hybrid Table - 100 Concurrent Mixed Workload" required>
            </div>

            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-textarea" x-model="config.description" placeholder="Describe what this template tests..."></textarea>
            </div>
        </div>

        <!-- Connection Selection -->
        <div class="card">
            <div class="card-title">Connection</div>
            
            <div class="form-group">
                <label class="form-label">Select Connection *</label>
                <select id="connection-select" class="form-select" x-model="config.connection_id" @change="onConnectionChanged()" required>
                    <option value="">-- Select a connection --</option>
                    <template x-for="conn in availableConnections" :key="conn.connection_id">
                        <option 
                            :value="conn.connection_id" 
                            x-text="conn.connection_name + ' (' + conn.connection_type + ')'"
                        ></option>
                    </template>
                </select>
                <small class="form-text">Choose which database connection to use for this test</small>
            </div>
        </div>

        <div class="card">
            <div class="card-title">Table Configuration</div>
            
            <!-- Object Type Filter - only show for Snowflake connections -->
            <div class="form-group" x-show="!isPostgresConnection()">
                <label class="form-label">Object Type Filter</label>
                <select class="form-select" x-model="objectTypeFilter" @change="onObjectTypeFilterChanged()">
                    <option value="ALL_SNOWFLAKE">All Snowflake</option>
                    <option value="STANDARD">Standard Tables</option>
                    <option value="HYBRID">Hybrid Tables</option>
                    <option value="DYNAMIC">Dynamic Tables</option>
                    <option value="INTERACTIVE">Interactive Tables</option>
                    <option value="VIEW">Views</option>
                </select>
                <small class="form-text">Filter by table type</small>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="form-group">
                    <label class="form-label">Database</label>
                    <select id="database-select" class="form-select" x-model="config.database" @change="onDatabaseChanged()" required>
                        <option value="">-- Select a database --</option>
                        <template x-for="db in availableDatabases" :key="db.name">
                            <option :value="String(db.name || '')" x-text="db.name"></option>
                        </template>
                    </select>
                    <small class="form-text">Select an existing database</small>
                </div>

                <div class="form-group">
                    <label class="form-label">Schema</label>
                    <select
                        id="schema-select"
                        class="form-select"
                        x-model="config.schema"
                        @change="onSchemaChanged()"
                        :disabled="!config.database"
                        required
                    >
                        <option value="">-- Select a schema --</option>
                        <template x-for="s in availableSchemas" :key="s.name">
                            <option :value="String(s.name || '')" x-text="s.name"></option>
                        </template>
                    </select>
                    <small class="form-text">Select an existing schema</small>
                </div>

                <div class="form-group">
                    <label class="form-label">Table / View</label>
                    <select id="table-select" class="form-select" x-model="config.table_name" @change="onTableSelected()" :disabled="!config.schema" required>
                        <option value="">-- Select a table or view --</option>
                        <template x-for="obj in availableObjects" :key="obj.detected_type + ':' + obj.name">
                            <option
                                :value="String(obj.name || '')"
                                x-text="objectDisplayName(obj)"
                            ></option>
                        </template>
                    </select>
                    <small class="form-text">Select an existing table or view</small>
                </div>
            </div>

            <div class="alert alert-info mt-3">
                <strong>Full Table Name:</strong> <code x-text="config.database + '.' + config.schema + '.' + config.table_name"></code>
                <span x-show="detectedTableType" class="ml-3">
                    <strong>Detected Type:</strong>
                    <span
                        class="inline-block px-2 py-0.5 text-xs font-semibold rounded"
                        :class="{
                            'bg-blue-100 text-blue-800': detectedTableType === 'STANDARD',
                            'bg-purple-100 text-purple-800': detectedTableType === 'HYBRID',
                            'bg-orange-100 text-orange-800': detectedTableType === 'INTERACTIVE',
                            'bg-green-100 text-green-800': detectedTableType === 'VIEW',
                            'bg-gray-100 text-gray-800': detectedTableType === 'TABLE'
                        }"
                        x-text="detectedTableType"
                    ></span>
                </span>
            </div>
        </div>

        <!-- Interactive Table Info & Warnings -->
        <div x-show="detectedTableType === 'INTERACTIVE' && (interactiveTableClusterBy || interactiveTableWarnings.length > 0)" class="card" style="border-left: 4px solid #f97316;">
            <div class="card-title" style="color: #c2410c;">
                <svg xmlns="http://www.w3.org/2000/svg" class="inline-block w-5 h-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                Interactive Table Configuration
            </div>
            
            <!-- Cluster Key Info -->
            <div x-show="interactiveTableClusterBy" class="mb-3">
                <strong>Cluster Key:</strong>
                <code class="ml-2 px-2 py-1 bg-gray-100 rounded text-sm" x-text="interactiveTableClusterBy ? '(' + interactiveTableClusterBy.join(', ') + ')' : 'N/A'"></code>
                <p class="text-sm text-gray-600 mt-1">
                    Interactive Tables have a 5-second query timeout. Queries must filter on the cluster key columns for optimal performance.
                </p>
            </div>

            <!-- Warnings -->
            <template x-for="(warning, idx) in interactiveTableWarnings" :key="idx">
                <div class="alert alert-warning mb-2" style="background-color: #fef3c7; border: 1px solid #f59e0b; color: #92400e;">
                    <span x-text="warning"></span>
                </div>
            </template>
        </div>

        <div class="card" x-show="config.table_type !== 'POSTGRES'">
            <div class="card-title">Warehouse Configuration</div>
            
            <div class="form-group">
                <label class="form-label">Select Warehouse</label>
                <select
                    id="warehouse-select"
                    class="form-select"
                    x-model="config.warehouse_name"
                    @change="loadWarehouseDetails"
                    :required="config.table_type !== 'POSTGRES'"
                >
                    <option value="">-- Select a warehouse --</option>
                    <template x-for="wh in availableWarehouses" :key="wh.name">
                        <option
                            :value="String(wh.name || '')"
                            x-text="formatWarehouseOption(wh)"
                        ></option>
                    </template>
                </select>
                <small class="form-text">Select existing warehouse - size and settings will be auto-populated</small>
            </div>
            
            <div x-show="config.warehouse_name" class="alert alert-info mt-3">
                <strong>Warehouse Details:</strong><br>
                <span x-show="selectedWarehouseDetails">
                    <strong>Name:</strong> <span x-text="selectedWarehouseDetails?.name || config.warehouse_name"></span><br>
                    <strong>Size:</strong> <span x-text="selectedWarehouseDetails?.size"></span><br>
                    <strong>State:</strong> <span x-text="selectedWarehouseDetails?.state"></span><br>
                    <strong>Type:</strong> <span x-text="selectedWarehouseDetails?.type"></span><br>
                    <strong>Generation:</strong> 
                    <span x-text="selectedWarehouseDetails?.resource_constraint === 'STANDARD_GEN_2' ? 'Gen 2' : 'Gen 1'"></span><br>
                    
                    <!-- Multi-Cluster Warehouse Details -->
                    <span x-show="selectedWarehouseDetails?.max_cluster_count > 1">
                        <hr class="my-2">
                        <strong>Multi-Cluster Configuration:</strong><br>
                        &nbsp;&nbsp;• Min Clusters: <span x-text="selectedWarehouseDetails?.min_cluster_count"></span><br>
                        &nbsp;&nbsp;• Max Clusters: <span x-text="selectedWarehouseDetails?.max_cluster_count"></span><br>
                        &nbsp;&nbsp;• Scaling Policy: <span x-text="selectedWarehouseDetails?.scaling_policy"></span><br>
                        &nbsp;&nbsp;• Currently Started: <span x-text="selectedWarehouseDetails?.started_clusters"></span> cluster(s)<br>
                    </span>
                    
                    <!-- Single Cluster -->
                    <span x-show="selectedWarehouseDetails?.max_cluster_count === 1">
                        <strong>Multi-Cluster:</strong> <span class="text-muted">Not Enabled (Single Cluster)</span><br>
                    </span>
                    
                    <!-- Query Acceleration Service (QAS) -->
                    <hr class="my-2">
                    <strong>Query Acceleration Service (QAS):</strong> 
                    <span x-text="selectedWarehouseDetails?.enable_query_acceleration ? 'Enabled' : 'Disabled'"></span>
                    <span x-show="selectedWarehouseDetails?.enable_query_acceleration">
                        (Max Scale Factor: <span x-text="selectedWarehouseDetails?.query_acceleration_max_scale_factor"></span>)
                    </span><br>
                    
                    <!-- Auto-Suspend/Resume Settings -->
                    <hr class="my-2">
                    <strong>Auto Settings:</strong><br>
                    &nbsp;&nbsp;• Auto-Suspend: <span x-text="selectedWarehouseDetails?.auto_suspend ? selectedWarehouseDetails.auto_suspend + ' seconds' : 'Disabled'"></span><br>
                    &nbsp;&nbsp;• Auto-Resume: <span x-text="selectedWarehouseDetails?.auto_resume ? 'Enabled' : 'Disabled'"></span><br>
                </span>
            </div>
        </div>
        
        <div class="card" x-show="isPostgresFamilyTableType(config.table_type)">
            <div class="card-title">Postgres Connection Settings</div>
            
            <div class="form-group">
                <label class="form-label" style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" x-model="config.use_pgbouncer" style="margin: 0;">
                    Use PgBouncer
                </label>
                <small class="form-text">
                    Connects via PgBouncer for connection pooling. Requires <code>snowflake_pooler</code> extension 
                    and a non-superuser role. <strong>Without PgBouncer: max 500 connections. With PgBouncer: up to 1000.</strong>
                </small>
            </div>

            <div class="alert alert-info mt-3">
                Warehouse selection is not used for Postgres-based templates. Results are still recorded to Snowflake using the `.env` `SNOWFLAKE_WAREHOUSE`.
            </div>
        </div>

        <div class="card">
            <div class="card-title">Queries, Mix, and Targets</div>
            <p class="text-sm text-gray-700">
                Templates store all SQL and mix weights. Mix presets only adjust weights (SQL is left unchanged).
            </p>

            <div class="form-group">
                <label class="form-label">Mix Preset</label>
                <select class="form-select" x-model="config.mix_preset" @change="applyMixPreset(config.mix_preset)" :disabled="isInteractiveTable(config.table_type)">
                    <option value="READ_ONLY">Read Only (50/50 reads)</option>
                    <option value="WRITE_ONLY" x-bind:disabled="isInteractiveTable(config.table_type)">Write Only (70/30 writes)</option>
                    <option value="READ_HEAVY" x-bind:disabled="isInteractiveTable(config.table_type)">Read Heavy (80/20)</option>
                    <option value="WRITE_HEAVY" x-bind:disabled="isInteractiveTable(config.table_type)">Write Heavy (20/80)</option>
                    <option value="MIXED" x-bind:disabled="isInteractiveTable(config.table_type)">Mixed (50/50)</option>
                    <option value="CUSTOM" x-bind:disabled="isInteractiveTable(config.table_type)">Custom (manual)</option>
                </select>
                <small class="form-text">
                    Presets only change the percentages below. They do <strong>not</strong> change SQL.
                </small>
            </div>

            <div x-show="isInteractiveTable(config.table_type)" class="alert alert-warning mt-3">
                <strong>⚠️ Interactive Table Limitation:</strong> Interactive tables do not support DML operations (INSERT, UPDATE, DELETE). 
                Only read operations (Point Lookup, Range Scan) are available for benchmarking.
                <a href="https://docs.snowflake.com/en/sql-reference/sql/create-interactive-table#usage-notes" target="_blank" rel="noopener">Learn more</a>
            </div>

            <div class="btn-group mt-2">
                <button
                    type="button"
                    class="btn btn-secondary"
                    :disabled="aiSqlAdjustLoading || !hasSelectedTable()"
                    @click="aiAdjustCustomSql()"
                >
                    <span class="loading-spinner" x-show="aiSqlAdjustLoading"></span>
                    <span x-text="aiSqlAdjustLoading ? 'Generating…' : 'Generate SQL for This Table Type'"></span>
                </button>
            </div>

            <div class="alert alert-info mt-3">
                <div class="text-sm">
                    <div><strong>SQL placeholder:</strong> use <code>{table}</code> for the full table name.</div>
                    <div x-show="isPostgresFamilyTableType(config.table_type)">
                        <strong>Parameters:</strong> Postgres uses <code>$1</code>, <code>$2</code>, …
                    </div>
                    <div x-show="!isPostgresFamilyTableType(config.table_type)">
                        <strong>Parameters:</strong> Snowflake uses <code>?</code>.
                    </div>
                    <div class="mt-1">
                        <strong>Strict evaluation:</strong> a run is compliant only if all enabled per-query targets are met.
                    </div>
                </div>
            </div>

            <div class="alert alert-info mt-3">
                <strong>Total mix must equal 100%.</strong>
                Current total:
                <code x-text="mixTotal() + '%'"></code>
            </div>

            <div class="overflow-x-auto mt-3">
                <table class="w-full border-collapse" style="table-layout: fixed;">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="p-2 text-left border-b-2 border-gray-200 whitespace-nowrap" style="width: 7rem;">Query Type</th>
                            <th class="p-2 text-right border-b-2 border-gray-200 whitespace-nowrap" style="width: 5rem;">Mix %</th>
                            <th class="p-2 text-right border-b-2 border-gray-200 whitespace-nowrap" style="width: 8rem;">P95 Target (ms)</th>
                            <th class="p-2 text-right border-b-2 border-gray-200 whitespace-nowrap" style="width: 8rem;">P99 Target (ms)</th>
                            <th class="p-2 text-right border-b-2 border-gray-200 whitespace-nowrap" style="width: 7rem;">Max Error %</th>
                            <th class="p-2 text-left border-b-2 border-gray-200">SQL (stored in template)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="p-2 border-b border-gray-200 font-medium">Point Lookup</td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right" style="width: 4.5rem;" x-model.number="config.custom_point_lookup_pct" min="0" max="100">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_point_lookup_p95_latency_ms" min="-1">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_point_lookup_p99_latency_ms" min="-1">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_point_lookup_error_rate_pct" min="-1" max="100" step="0.1">
                            </td>
                            <td class="p-2 border-b border-gray-200">
                                <template x-if="editingSql !== 'point_lookup'">
                                    <div class="flex items-start gap-2">
                                        <pre class="text-xs m-0 whitespace-pre-wrap break-words max-h-16 overflow-y-auto flex-1 bg-slate-50 p-1 px-2 rounded border border-slate-300" x-text="formatSqlDisplay(config.custom_point_lookup_query)"></pre>
                                        <button type="button" class="btn btn-secondary btn-sm flex-shrink-0" @click="toggleSqlEdit('point_lookup')">Edit</button>
                                    </div>
                                </template>
                                <template x-if="editingSql === 'point_lookup'">
                                    <div>
                                        <textarea class="form-textarea font-mono text-xs" rows="4" style="min-width: 28rem;" x-model="config.custom_point_lookup_query"></textarea>
                                        <button type="button" class="btn btn-primary btn-sm mt-1" @click="toggleSqlEdit('point_lookup')">Done</button>
                                    </div>
                                </template>
                            </td>
                        </tr>
                        <tr>
                            <td class="p-2 border-b border-gray-200 font-medium">Range Scan</td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right" style="width: 4.5rem;" x-model.number="config.custom_range_scan_pct" min="0" max="100">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_range_scan_p95_latency_ms" min="-1">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_range_scan_p99_latency_ms" min="-1">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_range_scan_error_rate_pct" min="-1" max="100" step="0.1">
                            </td>
                            <td class="p-2 border-b border-gray-200">
                                <template x-if="editingSql !== 'range_scan'">
                                    <div class="flex items-start gap-2">
                                        <pre class="text-xs m-0 whitespace-pre-wrap break-words max-h-16 overflow-y-auto flex-1 bg-slate-50 p-1 px-2 rounded border border-slate-300" x-text="formatSqlDisplay(config.custom_range_scan_query)"></pre>
                                        <button type="button" class="btn btn-secondary btn-sm flex-shrink-0" @click="toggleSqlEdit('range_scan')">Edit</button>
                                    </div>
                                </template>
                                <template x-if="editingSql === 'range_scan'">
                                    <div>
                                        <textarea class="form-textarea font-mono text-xs" rows="4" style="min-width: 28rem;" x-model="config.custom_range_scan_query"></textarea>
                                        <button type="button" class="btn btn-primary btn-sm mt-1" @click="toggleSqlEdit('range_scan')">Done</button>
                                    </div>
                                </template>
                            </td>
                        </tr>
                        <tr :class="{ 'opacity-50': isInteractiveTable(config.table_type) }">
                            <td class="p-2 border-b border-gray-200 font-medium">
                                Insert
                                <span x-show="isInteractiveTable(config.table_type)" class="text-xs text-red-600 block">(N/A)</span>
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right" style="width: 4.5rem;" x-model.number="config.custom_insert_pct" min="0" max="100" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_insert_p95_latency_ms" min="-1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_insert_p99_latency_ms" min="-1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_insert_error_rate_pct" min="-1" max="100" step="0.1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 border-b border-gray-200">
                                <template x-if="editingSql !== 'insert' && !isInteractiveTable(config.table_type)">
                                    <div class="flex items-start gap-2">
                                        <pre class="text-xs m-0 whitespace-pre-wrap break-words max-h-16 overflow-y-auto flex-1 bg-slate-50 p-1 px-2 rounded border border-slate-300" x-text="formatSqlDisplay(config.custom_insert_query)"></pre>
                                        <button type="button" class="btn btn-secondary btn-sm flex-shrink-0" @click="toggleSqlEdit('insert')">Edit</button>
                                    </div>
                                </template>
                                <template x-if="isInteractiveTable(config.table_type)">
                                    <span class="text-xs text-gray-500 italic">Not supported on interactive tables</span>
                                </template>
                                <template x-if="editingSql === 'insert' && !isInteractiveTable(config.table_type)">
                                    <div>
                                        <textarea class="form-textarea font-mono text-xs" rows="4" style="min-width: 28rem;" x-model="config.custom_insert_query"></textarea>
                                        <button type="button" class="btn btn-primary btn-sm mt-1" @click="toggleSqlEdit('insert')">Done</button>
                                    </div>
                                </template>
                            </td>
                        </tr>
                        <tr :class="{ 'opacity-50': isInteractiveTable(config.table_type) }">
                            <td class="p-2 font-medium">
                                Update
                                <span x-show="isInteractiveTable(config.table_type)" class="text-xs text-red-600 block">(N/A)</span>
                            </td>
                            <td class="p-2 text-right">
                                <input type="number" class="form-input text-right" style="width: 4.5rem;" x-model.number="config.custom_update_pct" min="0" max="100" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_update_p95_latency_ms" min="-1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_update_p99_latency_ms" min="-1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_update_error_rate_pct" min="-1" max="100" step="0.1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2">
                                <template x-if="editingSql !== 'update' && !isInteractiveTable(config.table_type)">
                                    <div class="flex items-start gap-2">
                                        <pre class="text-xs m-0 whitespace-pre-wrap break-words max-h-16 overflow-y-auto flex-1 bg-slate-50 p-1 px-2 rounded border border-slate-300" x-text="formatSqlDisplay(config.custom_update_query)"></pre>
                                        <button type="button" class="btn btn-secondary btn-sm flex-shrink-0" @click="toggleSqlEdit('update')">Edit</button>
                                    </div>
                                </template>
                                <template x-if="isInteractiveTable(config.table_type)">
                                    <span class="text-xs text-gray-500 italic">Not supported on interactive tables</span>
                                </template>
                                <template x-if="editingSql === 'update' && !isInteractiveTable(config.table_type)">
                                    <div>
                                        <textarea class="form-textarea font-mono text-xs" rows="4" style="min-width: 28rem;" x-model="config.custom_update_query"></textarea>
                                        <button type="button" class="btn btn-primary btn-sm mt-1" @click="toggleSqlEdit('update')">Done</button>
                                    </div>
                                </template>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <small class="form-text mt-2">
                Tip: leave a target at <code>-1</code> to disable it for that query type.
            </small>
        </div>

        <!-- Load & Scaling Card (compact 2-column layout) -->
        <div class="card">
            <div class="card-title">Load & Scaling</div>

            <!-- Mode selectors always at top, side by side -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                <div class="form-group" style="margin-bottom: 0;">
                    <label class="form-label">Load Mode</label>
                    <select class="form-select" x-model="config.load_mode">
                        <option value="CONCURRENCY">Fixed threads</option>
                        <option value="QPS">Target throughput (QPS)</option>
                        <option value="FIND_MAX_CONCURRENCY">Find max throughput</option>
                    </select>
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label class="form-label">Scaling Mode</label>
                    <select class="form-select" x-model="config.scaling.mode">
                        <option value="AUTO">Auto</option>
                        <option value="BOUNDED">Bounded</option>
                        <option value="FIXED">Fixed</option>
                    </select>
                </div>
            </div>

            <!-- CONCURRENCY mode options -->
            <div x-show="String(config.load_mode || 'CONCURRENCY').toUpperCase() === 'CONCURRENCY'">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <!-- Left: Load parameters -->
                    <div>
                        <div style="padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 0.75rem; background-color: #eff6ff; border: 1px solid #bfdbfe;">
                            <div style="font-size: 0.875rem; color: #1e40af;">
                                <strong>Fixed Threads</strong> maintains constant concurrency throughout the test.
                                All threads run continuously for the specified duration.
                            </div>
                        </div>
                        <!-- Threads field - hidden when FIXED scaling -->
                        <div class="form-group" x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() !== 'FIXED'">
                            <label class="form-label">Total Threads</label>
                            <input type="number" class="form-input" x-model.number="config.concurrent_connections" min="1">
                            <small class="form-text">Concurrent operations across all workers</small>
                        </div>
                        <!-- Timing -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Warmup (s)</label>
                                <input type="number" class="form-input" x-model.number="config.warmup" min="0" max="300">
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Duration (s)</label>
                                <input type="number" class="form-input" x-model.number="config.duration" min="10" max="3600">
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Think (ms)</label>
                                <input type="number" class="form-input" x-model.number="config.think_time" min="0" max="10000">
                            </div>
                        </div>
                    </div>
                    <!-- Right: Scaling parameters -->
                    <div>
                        <!-- AUTO mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'AUTO'" style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #f3f4f6; color: #6b7280; margin-bottom: 0.75rem;">
                            Workers computed automatically from total threads.
                        </div>
                        <!-- FIXED mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'FIXED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Threads/Worker</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_connections" min="1" max="200" step="1">
                                </div>
                            </div>
                            <div style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #dbeafe; color: #1e40af;">
                                <strong>Total:</strong> 
                                <span x-text="(Number(config.scaling?.min_workers) || 1) + ' × ' + (Number(config.scaling?.min_connections) || 1) + ' = ' + ((Number(config.scaling?.min_workers) || 1) * (Number(config.scaling?.min_connections) || 1)) + ' threads'"></span>
                            </div>
                        </div>
                        <!-- BOUNDED mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'BOUNDED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Min Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Max Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.max_workers" min="1" step="1" placeholder="∞">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Min Threads/Wkr</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_connections" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Max Threads/Wkr</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.max_connections" min="1" max="200" step="1" placeholder="200">
                                </div>
                            </div>
                        </div>
                        <!-- Resource Guardrails -->
                        <div style="padding: 0.5rem; border-radius: 0.25rem; background-color: #f9fafb; border: 1px solid #e5e7eb;">
                            <label style="font-size: 0.75rem; display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-weight: 500;">
                                <input type="checkbox" x-model="config.guardrails.enabled" style="margin: 0;">
                                <span>Resource Guardrails</span>
                            </label>
                            <div x-show="config.guardrails?.enabled !== false" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 0.75rem;">CPU %</label>
                                    <input type="number" class="form-input" x-model.number="config.guardrails.max_cpu_percent" min="1" max="100" step="1">
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 0.75rem;">Memory %</label>
                                    <input type="number" class="form-input" x-model.number="config.guardrails.max_memory_percent" min="1" max="100" step="1">
                                </div>
                            </div>
                            <small x-show="config.guardrails?.enabled === false" style="color: #9ca3af; font-size: 0.75rem;">
                                No host resource limits
                            </small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- QPS mode options -->
            <div x-show="String(config.load_mode || 'CONCURRENCY').toUpperCase() === 'QPS'">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <!-- Left: Load parameters -->
                    <div>
                        <div style="padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 0.75rem; background-color: #eff6ff; border: 1px solid #bfdbfe;">
                            <div style="font-size: 0.875rem; color: #1e40af;">
                                <strong>Target Throughput</strong> adjusts threads dynamically to achieve desired QPS.
                                System adds or removes threads to maintain the specified operations per second.
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Target QPS</label>
                            <input type="number" class="form-input" x-model.number="config.target_qps" min="1" max="100000" step="1">
                            <small class="form-text">Operations per second</small>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Starting Threads</label>
                                <input type="number" class="form-input" x-model.number="config.starting_threads" min="0" step="1" placeholder="0">
                                <small class="form-text">Initial threads (0 = ramp from min)</small>
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Max Threads/Interval</label>
                                <input type="number" class="form-input" x-model.number="config.max_thread_increase" min="1" max="200" step="1" placeholder="15">
                                <small class="form-text">Max thread increase (~10s)</small>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Warmup (s)</label>
                                <input type="number" class="form-input" x-model.number="config.warmup" min="0" max="300">
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Duration (s)</label>
                                <input type="number" class="form-input" x-model.number="config.duration" min="10" max="3600">
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Think (ms)</label>
                                <input type="number" class="form-input" x-model.number="config.think_time" min="0" max="10000">
                            </div>
                        </div>
                    </div>
                    <!-- Right: Scaling parameters (same as CONCURRENCY) -->
                    <div>
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'AUTO'" style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #f3f4f6; color: #6b7280; margin-bottom: 0.75rem;">
                            Workers scale dynamically to meet QPS target.
                        </div>
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'FIXED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Threads/Worker</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_connections" min="1" max="200" step="1">
                                </div>
                            </div>
                        </div>
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'BOUNDED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Min Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Max Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.max_workers" min="1" step="1" placeholder="∞">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Min Threads/Wkr</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_connections" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Max Threads/Wkr</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.max_connections" min="1" max="200" step="1" placeholder="200">
                                </div>
                            </div>
                        </div>
                        <div style="padding: 0.5rem; border-radius: 0.25rem; background-color: #f9fafb; border: 1px solid #e5e7eb;">
                            <label style="font-size: 0.75rem; display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-weight: 500;">
                                <input type="checkbox" x-model="config.guardrails.enabled" style="margin: 0;">
                                <span>Resource Guardrails</span>
                            </label>
                            <div x-show="config.guardrails?.enabled !== false" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 0.75rem;">CPU %</label>
                                    <input type="number" class="form-input" x-model.number="config.guardrails.max_cpu_percent" min="1" max="100" step="1">
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 0.75rem;">Memory %</label>
                                    <input type="number" class="form-input" x-model.number="config.guardrails.max_memory_percent" min="1" max="100" step="1">
                                </div>
                            </div>
                            <small x-show="config.guardrails?.enabled === false" style="color: #9ca3af; font-size: 0.75rem;">
                                No host resource limits
                            </small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FIND_MAX_CONCURRENCY mode options -->
            <div x-show="String(config.load_mode || 'CONCURRENCY').toUpperCase() === 'FIND_MAX_CONCURRENCY'">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <!-- Left: Find Max parameters -->
                    <div>
                        <div style="padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 0.75rem; background-color: #eff6ff; border: 1px solid #bfdbfe;">
                            <div style="font-size: 0.875rem; color: #1e40af;">
                                <strong>Find Max Throughput</strong> runs until degradation or max threads reached.
                                Starts at initial threads, increments each step until QPS drops, latency spikes, or errors increase.
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Start Threads</label>
                                <input type="number" class="form-input" x-model.number="config.start_concurrency" min="1" max="100" step="1">
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Increment</label>
                                <input type="number" class="form-input" x-model.number="config.concurrency_increment" min="1" max="100" step="1">
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Step Duration (s)</label>
                                <input type="number" class="form-input" x-model.number="config.step_duration_seconds" min="10" max="300" step="5">
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="font-size: 0.75rem;">Warmup (s)</label>
                                <input type="number" class="form-input" x-model.number="config.warmup" min="0" max="300">
                            </div>
                        </div>

                        <details style="margin-bottom: 0.75rem;">
                            <summary style="font-size: 0.875rem; font-weight: 600; cursor: pointer; color: #6b7280;">
                                Advanced: stability thresholds
                            </summary>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.75rem; margin-top: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">QPS Drop %</label>
                                    <input type="number" class="form-input" x-model.number="config.qps_stability_pct" min="1" max="50" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">P95 Latency %</label>
                                    <input type="number" class="form-input" x-model.number="config.latency_stability_pct" min="5" max="100" step="5">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Max Error %</label>
                                    <input type="number" class="form-input" x-model.number="config.max_error_rate_pct" min="0" max="100" step="0.5">
                                </div>
                            </div>
                        </details>

                        <div style="padding: 0.5rem; border-radius: 0.25rem; background-color: #f9fafb; border: 1px solid #e5e7eb; max-width: 350px;">
                            <label style="font-size: 0.75rem; display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-weight: 500;">
                                <input type="checkbox" x-model="config.guardrails.enabled" style="margin: 0;">
                                <span>Resource Guardrails</span>
                            </label>
                            <div x-show="config.guardrails?.enabled !== false" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 0.75rem;">CPU %</label>
                                    <input type="number" class="form-input" x-model.number="config.guardrails.max_cpu_percent" min="1" max="100" step="1">
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 0.75rem;">Memory %</label>
                                    <input type="number" class="form-input" x-model.number="config.guardrails.max_memory_percent" min="1" max="100" step="1">
                                </div>
                            </div>
                            <small x-show="config.guardrails?.enabled === false" style="color: #9ca3af; font-size: 0.75rem;">
                                No host resource limits
                            </small>
                        </div>
                    </div>

                    <!-- Right: Scaling parameters -->
                    <div>
                        <!-- AUTO mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'AUTO'" style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #f3f4f6; color: #6b7280; margin-bottom: 0.75rem;">
                            Workers computed automatically as threads increase.
                        </div>
                        <!-- FIXED mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'FIXED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Threads/Worker</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_connections" min="1" max="200" step="1">
                                </div>
                            </div>
                            <div style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #dbeafe; color: #1e40af;">
                                Find Max will increment threads within fixed worker count
                            </div>
                        </div>
                        <!-- BOUNDED mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'BOUNDED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Min Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Max Workers</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.max_workers" min="1" step="1" placeholder="∞">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Min Threads/Wkr</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.min_connections" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" style="font-size: 0.75rem;">Max Threads/Wkr</label>
                                    <input type="number" class="form-input" x-model.number="config.scaling.max_connections" min="1" max="200" step="1" placeholder="200">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Execution Options (compact inline checkbox) -->
        <div class="card" x-show="config.table_type === 'STANDARD' || config.table_type === 'INTERACTIVE'" style="padding: 0.75rem 1rem;">
            <label style="display: flex; align-items: center; gap: 0.5rem; margin: 0; cursor: pointer;">
                <input type="checkbox" x-model="config.use_cached_result" style="margin: 0;">
                <span style="font-size: 0.875rem;">Use Snowflake result cache (<code style="font-size: 0.8em;">USE_CACHED_RESULT</code>)</span>
            </label>
        </div>

        <!-- Stale Value Pools Warning -->
        <div class="alert alert-warning" x-show="mode === 'edit' && arePoolsStale()" style="margin-bottom: 1rem; display: flex; align-items: flex-start; gap: 0.75rem;">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path>
                <line x1="12" y1="9" x2="12" y2="13"></line>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
            <div>
                <strong>Value pools may be outdated.</strong>
                <span x-text="'Pools were created for ' + getPoolSourceTable() + ' but the template now targets a different table.'"></span>
                Click <strong x-text="mode === 'edit' ? 'Update & Populate' : 'Save & Populate'"></strong> to regenerate them.
            </div>
        </div>

        <div class="btn-group" x-show="!isReadOnly" x-data="{ saveMenuOpen: false }">
            <!-- Split button: Smart defaults based on pool state -->
            <div class="split-btn-container">
                <button
                    type="button"
                    class="btn btn-primary split-btn-main"
                    :disabled="isSaving || aiPrepLoading || saveAndPrepareLoading || (mode === 'edit' && !isDirty())"
                    @click="(hasExistingPools() && !arePoolsStale()) ? submitTest() : saveAndPrepare()"
                    :title="(hasExistingPools() && !arePoolsStale()) 
                        ? 'Saves template settings without regenerating value pools' 
                        : 'Saves template and generates value pools via Snowflake SAMPLE. Value pools provide realistic parameter values and skip expensive table profiling on each run.'"
                >
                    <span class="loading-spinner" x-show="saveAndPrepareLoading || isSaving"></span>
                    <span x-text="(saveAndPrepareLoading || isSaving) 
                        ? (mode === 'edit' ? 'Updating…' : 'Saving…') 
                        : (mode === 'edit' ? 'Update' : 'Save')"></span>
                </button>
                <button
                    type="button"
                    class="btn btn-primary split-btn-toggle"
                    :disabled="isSaving || aiPrepLoading || saveAndPrepareLoading || (mode === 'edit' && !isDirty())"
                    @click="saveMenuOpen = !saveMenuOpen"
                    @click.away="saveMenuOpen = false"
                    aria-haspopup="true"
                    :aria-expanded="saveMenuOpen"
                >
                    <svg class="split-btn-caret" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd" />
                    </svg>
                </button>
                <div class="split-btn-menu" x-show="saveMenuOpen" x-transition>
                    <button
                        type="button"
                        class="split-btn-menu-item"
                        @click="saveAndPrepare(); saveMenuOpen = false"
                        :disabled="isSaving || aiPrepLoading || saveAndPrepareLoading || (mode === 'edit' && !isDirty())"
                    >
                        <span class="split-btn-menu-label" x-text="mode === 'edit' ? 'Update & Populate' : 'Save & Populate'"></span>
                        <span class="split-btn-menu-desc">Generates value pools for realistic benchmark parameters</span>
                    </button>
                    <button
                        type="button"
                        class="split-btn-menu-item"
                        @click="submitTest(); saveMenuOpen = false"
                        :disabled="isSaving || (mode === 'edit' && !isDirty())"
                    >
                        <span class="split-btn-menu-label" x-text="mode === 'edit' ? 'Update Only' : 'Save Only'"></span>
                        <span class="split-btn-menu-desc">Quick save without value pools — useful when iterating on settings</span>
                    </button>
                </div>
            </div>
            <button
                type="button"
                class="btn btn-primary"
                x-show="loadedTemplate"
                :disabled="isTemplateActionInProgress()"
                @click="prepareTemplate()"
            >
                <span class="loading-spinner" x-show="prepareTemplateLoading"></span>
                <span x-text="prepareTemplateLoading ? 'Loading…' : 'Run'"></span>
            </button>
            <button type="button" class="btn btn-secondary" :disabled="isTemplateActionInProgress()" @click="cancel" x-text="loadedTemplate ? 'Close' : 'Cancel'"></button>
        </div>
        </fieldset>
    </form>

    <!-- Value Pool Status (shown in view mode) -->
    <div x-show="isReadOnly && loadedTemplate" class="card">
        <div class="card-title">Value Pool Status</div>
        
        <div x-show="!config.ai_workload || !config.ai_workload.pool_id" class="alert alert-warning">
            <strong>Not populated.</strong> This template has not been populated with value pools.
            <span x-show="hasResults">Copy this template to create an editable version that can be populated.</span>
        </div>

        <div x-show="aiPrepError && isReadOnly" class="alert alert-error mt-3">
            <strong>Value pool population failed.</strong>
            <span x-text="aiPrepError"></span>
        </div>

        <div x-show="config.ai_workload && config.ai_workload.pool_id" class="alert alert-success">
            <div class="text-sm">
                <div>
                    <strong>Populated:</strong> Yes
                    <span x-show="config.ai_workload?.prepared_at">
                        • <strong>At:</strong> <code x-text="config.ai_workload?.prepared_at || ''"></code>
                    </span>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.pool_id">
                    <strong>Pool ID:</strong> <code x-text="config.ai_workload?.pool_id || ''"></code>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.key_column">
                    <strong>Key column:</strong> <code x-text="config.ai_workload?.key_column || ''"></code>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.time_column">
                    <strong>Time column:</strong> <code x-text="config.ai_workload?.time_column || ''"></code>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.range_mode">
                    <strong>Range mode:</strong> <code x-text="config.ai_workload?.range_mode || ''"></code>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.domain_label">
                    <strong>Domain:</strong> <code x-text="config.ai_workload?.domain_label || ''"></code>
                </div>
                <div class="mt-2" x-show="config.ai_workload?.pools">
                    <strong>Pools:</strong>
                    <pre class="bg-gray-800 text-gray-100 p-3 rounded text-xs overflow-x-auto mt-1"><code x-text="JSON.stringify(config.ai_workload?.pools || {}, null, 2)"></code></pre>
                </div>
                <div class="mt-2" x-show="config.ai_workload?.ai_notes">
                    <strong>AI Notes:</strong>
                    <div class="text-xs text-gray-600 mt-1" x-text="config.ai_workload?.ai_notes || ''"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Actions when template has results -->
    <div x-show="hasResults || isReadOnly" class="card">
        <div class="btn-group">
            <button 
                type="button" 
                class="btn btn-primary" 
                :disabled="isTemplateActionInProgress()"
                @click="prepareTemplate()"
            >
                <span class="loading-spinner" x-show="prepareTemplateLoading"></span>
                <span x-text="prepareTemplateLoading ? 'Loading…' : 'Run'"></span>
            </button>
            <button 
                type="button" 
                class="btn btn-secondary" 
                :disabled="isTemplateActionInProgress()"
                @click="copyTemplate"
            >
                <span class="loading-spinner" x-show="copyTemplateLoading"></span>
                <span x-text="copyTemplateLoading ? 'Copying…' : 'Copy Template'"></span>
            </button>
            <button 
                type="button" 
                class="btn btn-danger" 
                :disabled="isTemplateActionInProgress()"
                @click="deleteTemplateWithResults"
            >
                <span class="loading-spinner" x-show="deleteTemplateLoading"></span>
                <span x-text="deleteTemplateLoading ? 'Deleting…' : 'Delete Template & Results'"></span>
            </button>
            <button type="button" class="btn btn-secondary" :disabled="isTemplateActionInProgress()" @click="cancel">
                Close
            </button>
        </div>
    </div>
</div>
    </div>
{% endblock %}

{% block extra_scripts %}
<script>
function testConfiguration() {
    return {
        config: {
            connection_id: '',  // Selected connection UUID
            table_type: 'STANDARD',
            database: '{{ default_database }}',
            schema: 'PUBLIC',
            table_name: '',
            warehouse_name: '',
            warehouse_size: 'MEDIUM',
            multi_cluster: false,
            min_clusters: 1,
            max_clusters: 3,
            scaling_policy: 'STANDARD',
            duration: 300,
            load_mode: 'CONCURRENCY',
            target_qps: 100,
            starting_threads: null,
            max_thread_increase: 15,
            scaling: {
                mode: 'AUTO',
                min_workers: 1,
                max_workers: null,
                min_connections: 5,
                max_connections: null,
            },
            guardrails: {
                enabled: true,
                max_cpu_percent: 80,
                max_memory_percent: 85,
            },
            concurrent_connections: 10,
            // FIND_MAX_CONCURRENCY mode defaults
            start_concurrency: 5,
            concurrency_increment: 10,
            step_duration_seconds: 30,
            qps_stability_pct: 5.0,
            latency_stability_pct: 20.0,
            max_error_rate_pct: 1.0,
            // Canonical storage model: templates persist CUSTOM SQL + weights.
            // "Mix preset" is a UI helper that only adjusts weights.
            workload_type: 'CUSTOM',
            mix_preset: 'MIXED',
            think_time: 0,
            warmup: 30,
            use_cached_result: true,
            use_pgbouncer: false,  // PgBouncer may not be available on all instances
            custom_point_lookup_query: 'SELECT * FROM {table} WHERE id = ?',
            custom_range_scan_query:
                'SELECT * FROM {table} WHERE id BETWEEN ? AND ? + 100 ORDER BY id LIMIT 100',
            custom_insert_query:
                'INSERT INTO {table} (id, data, timestamp) VALUES (?, ?, CURRENT_TIMESTAMP)',
            custom_update_query:
                'UPDATE {table} SET data = ?, timestamp = CURRENT_TIMESTAMP WHERE id = ?',
            custom_point_lookup_pct: 25,
            custom_range_scan_pct: 25,
            custom_insert_pct: 35,
            custom_update_pct: 15,
            // Per-query-type targets (SLOs). Use -1 to disable a target.
            target_point_lookup_p95_latency_ms: -1,
            target_range_scan_p95_latency_ms: -1,
            target_insert_p95_latency_ms: -1,
            target_update_p95_latency_ms: -1,
            target_point_lookup_p99_latency_ms: -1,
            target_range_scan_p99_latency_ms: -1,
            target_insert_p99_latency_ms: -1,
            target_update_p99_latency_ms: -1,
            target_point_lookup_error_rate_pct: -1,
            target_range_scan_error_rate_pct: -1,
            target_insert_error_rate_pct: -1,
            target_update_error_rate_pct: -1,
            template_name: '',
            description: ''
        },
        loadedTemplate: null,
        availableConnections: [],  // List of available database connections
        availableWarehouses: [],
        selectedWarehouseDetails: null,
        resultsWarehouse: null,
        availableDatabases: [],
        availableSchemas: [],
        availableObjects: [],
        objectTypeFilter: 'ALL_SNOWFLAKE',
        detectedTableType: null,
        interactiveTableClusterBy: null, // Cluster key columns for Interactive Tables
        interactiveTableWarnings: [], // Validation warnings for Interactive Tables
        mode: 'new', // 'new', 'edit', or 'view'
        hasResults: false, // true if template has been used
        isReadOnly: false,
        isInitializing: true,
        isSaving: false,
        error: null,
        aiPrepLoading: false,
        aiPrepError: null,
        aiPrepResult: null,
        aiPrepStatusFromConfig(msg = 'Loaded from template') {
            const w = this.config && this.config.ai_workload ? this.config.ai_workload : null;
            if (!w || typeof w !== 'object') return null;
            const prepared = Boolean(w.pool_id);
            const cortexAvailable = Boolean(
                (w.ai_available != null ? w.ai_available : w.available) || false,
            );
            const cortexError =
                (w.ai_error != null ? w.ai_error : w.availability_error) || null;
            return {
                message: msg,
                prepared,
                prepared_at: w.prepared_at || null,
                pool_id: w.pool_id || null,
                key_column: w.key_column || null,
                time_column: w.time_column || null,
                range_mode: w.range_mode || null,
                pools: w.pools || null,
                cortex_available: cortexAvailable,
                cortex_error: cortexError,
            };
        },
        aiSqlAdjustLoading: false,
        saveAndPrepareLoading: false,
        prepareTemplateLoading: false,
        copyTemplateLoading: false,
        deleteTemplateLoading: false,
        savedConfigSnapshot: null,

        isDirty() {
            if (!this.savedConfigSnapshot) return false;
            return JSON.stringify(this.getComparableConfig()) !== JSON.stringify(this.savedConfigSnapshot);
        },

        getComparableConfig() {
            const c = this.config;
            return {
                connection_id: c.connection_id,
                template_name: c.template_name,
                description: c.description,
                table_type: c.table_type,
                database: c.database,
                schema: c.schema,
                table_name: c.table_name,
                warehouse_name: c.warehouse_name,
                duration: c.duration,
                warmup: c.warmup,
                think_time: c.think_time,
                load_mode: c.load_mode,
                target_qps: c.target_qps,
                starting_threads: c.starting_threads,
                max_thread_increase: c.max_thread_increase,
                concurrent_connections: c.concurrent_connections,
                start_concurrency: c.start_concurrency,
                concurrency_increment: c.concurrency_increment,
                step_duration_seconds: c.step_duration_seconds,
                mix_preset: c.mix_preset,
                custom_point_lookup_pct: c.custom_point_lookup_pct,
                custom_range_scan_pct: c.custom_range_scan_pct,
                custom_insert_pct: c.custom_insert_pct,
                custom_update_pct: c.custom_update_pct,
                custom_point_lookup_query: c.custom_point_lookup_query,
                custom_range_scan_query: c.custom_range_scan_query,
                custom_insert_query: c.custom_insert_query,
                custom_update_query: c.custom_update_query,
                use_cached_result: c.use_cached_result,
                use_pgbouncer: c.use_pgbouncer,
                scaling: JSON.stringify(c.scaling || {}),
                guardrails: JSON.stringify(c.guardrails || {}),
            };
        },

        snapshotConfig() {
            this.savedConfigSnapshot = this.getComparableConfig();
        },

        // Check if any template action is in progress
        isTemplateActionInProgress() {
            return (
                this.prepareTemplateLoading ||
                this.copyTemplateLoading ||
                this.deleteTemplateLoading
            );
        },

        hasSelectedTable() {
            const db = String(this.config.database || '').trim();
            const sch = String(this.config.schema || '').trim();
            const tbl = String(this.config.table_name || '').trim();
            return Boolean(db && sch && tbl);
        },

        // Check if value pools exist for this template
        hasExistingPools() {
            return Boolean(this.config.ai_workload?.pool_id);
        },

        // Check if value pools are stale (created for a different table)
        arePoolsStale() {
            const aw = this.config.ai_workload;
            if (!aw?.pool_id) return false; // No pools = not stale
            // Compare current selection vs what pools were created for
            const currentDb = String(this.config.database || '').trim().toUpperCase();
            const currentSchema = String(this.config.schema || '').trim().toUpperCase();
            const currentTable = String(this.config.table_name || '').trim().toUpperCase();
            const sourceDb = String(aw.source_database || '').trim().toUpperCase();
            const sourceSchema = String(aw.source_schema || '').trim().toUpperCase();
            const sourceTable = String(aw.source_table || '').trim().toUpperCase();
            // If source fields are missing (legacy templates), can't determine staleness
            if (!sourceDb || !sourceSchema || !sourceTable) return false;
            return currentDb !== sourceDb || currentSchema !== sourceSchema || currentTable !== sourceTable;
        },

        // Get the original table name that pools were created for (for warning message)
        getPoolSourceTable() {
            const aw = this.config.ai_workload;
            if (!aw?.source_database) return null;
            return `${aw.source_database}.${aw.source_schema}.${aw.source_table}`;
        },

        // Check if the selected connection is a Postgres connection
        isPostgresConnection() {
            if (!this.config.connection_id) return false;
            const conn = (this.availableConnections || []).find(
                c => c.connection_id === this.config.connection_id
            );
            return conn?.connection_type === 'POSTGRES';
        },

        // Get the selected connection object
        getSelectedConnection() {
            if (!this.config.connection_id) return null;
            return (this.availableConnections || []).find(
                c => c.connection_id === this.config.connection_id
            ) || null;
        },

        isPostgresFamilyTableType(tableType) {
            const tt = String(tableType || '').trim().toUpperCase();
            return tt === 'POSTGRES';
        },

        isInteractiveTable(tableType) {
            const tt = String(tableType || '').trim().toUpperCase();
            return tt === 'INTERACTIVE';
        },

        mixTotal() {
            return (
                Number(this.config.custom_point_lookup_pct || 0) +
                Number(this.config.custom_range_scan_pct || 0) +
                Number(this.config.custom_insert_pct || 0) +
                Number(this.config.custom_update_pct || 0)
            );
        },

        editingSql: null, // tracks which SQL field is being edited: 'point_lookup', 'range_scan', 'insert', 'update', or null

        toggleSqlEdit(field) {
            this.editingSql = this.editingSql === field ? null : field;
        },

        formatSqlDisplay(sql) {
            const s = String(sql || '').trim();
            if (!s) return '(empty)';
            return s;
        },

        applyMixPreset(preset) {
            const p = String(preset || '').trim().toUpperCase();
            const presets = {
                READ_ONLY: { custom_point_lookup_pct: 50, custom_range_scan_pct: 50, custom_insert_pct: 0, custom_update_pct: 0 },
                WRITE_ONLY: { custom_point_lookup_pct: 0, custom_range_scan_pct: 0, custom_insert_pct: 70, custom_update_pct: 30 },
                READ_HEAVY: { custom_point_lookup_pct: 40, custom_range_scan_pct: 40, custom_insert_pct: 15, custom_update_pct: 5 },
                WRITE_HEAVY: { custom_point_lookup_pct: 10, custom_range_scan_pct: 10, custom_insert_pct: 60, custom_update_pct: 20 },
                MIXED: { custom_point_lookup_pct: 25, custom_range_scan_pct: 25, custom_insert_pct: 35, custom_update_pct: 15 },
            };

            // Always persist CUSTOM workloads; presets only affect weights.
            this.config.workload_type = 'CUSTOM';

            if (p === 'CUSTOM') {
                this.config.mix_preset = 'CUSTOM';
                return;
            }
            const w = presets[p];
            if (!w) {
                this.config.mix_preset = 'CUSTOM';
                return;
            }
            this.config.custom_point_lookup_pct = w.custom_point_lookup_pct;
            this.config.custom_range_scan_pct = w.custom_range_scan_pct;
            this.config.custom_insert_pct = w.custom_insert_pct;
            this.config.custom_update_pct = w.custom_update_pct;
            this.config.mix_preset = p;
        },

        syncMixPresetFromWeights() {
            const presets = {
                READ_ONLY: { custom_point_lookup_pct: 50, custom_range_scan_pct: 50, custom_insert_pct: 0, custom_update_pct: 0 },
                WRITE_ONLY: { custom_point_lookup_pct: 0, custom_range_scan_pct: 0, custom_insert_pct: 70, custom_update_pct: 30 },
                READ_HEAVY: { custom_point_lookup_pct: 40, custom_range_scan_pct: 40, custom_insert_pct: 15, custom_update_pct: 5 },
                WRITE_HEAVY: { custom_point_lookup_pct: 10, custom_range_scan_pct: 10, custom_insert_pct: 60, custom_update_pct: 20 },
                MIXED: { custom_point_lookup_pct: 25, custom_range_scan_pct: 25, custom_insert_pct: 35, custom_update_pct: 15 },
            };

            const weights = {
                custom_point_lookup_pct: Number(this.config.custom_point_lookup_pct || 0),
                custom_range_scan_pct: Number(this.config.custom_range_scan_pct || 0),
                custom_insert_pct: Number(this.config.custom_insert_pct || 0),
                custom_update_pct: Number(this.config.custom_update_pct || 0),
            };

            for (const [k, v] of Object.entries(presets)) {
                const match =
                    weights.custom_point_lookup_pct === v.custom_point_lookup_pct &&
                    weights.custom_range_scan_pct === v.custom_range_scan_pct &&
                    weights.custom_insert_pct === v.custom_insert_pct &&
                    weights.custom_update_pct === v.custom_update_pct;
                if (match) {
                    this.config.mix_preset = k;
                    return;
                }
            }
            this.config.mix_preset = 'CUSTOM';
        },

        ensureCanonicalWorkloadConfig() {
            // Canonical: templates always store CUSTOM SQL + weights.
            this.config.workload_type = 'CUSTOM';

            // Backfill mix_preset (UI helper).
            if (this.config.mix_preset == null) {
                this.config.mix_preset = 'CUSTOM';
            }
            if (!this.config.scaling || typeof this.config.scaling !== 'object') {
                this.config.scaling = {};
            }
            if (!String(this.config.scaling.mode || '').trim()) {
                this.config.scaling.mode = 'AUTO';
            }
            if (this.config.scaling.min_workers == null || String(this.config.scaling.min_workers).trim() === '') {
                this.config.scaling.min_workers = 1;
            }
            if (String(this.config.scaling.max_workers || '').trim() === '' || Number(this.config.scaling.max_workers) === -1) {
                this.config.scaling.max_workers = null;
            }
            if (this.config.scaling.min_connections == null || String(this.config.scaling.min_connections).trim() === '') {
                this.config.scaling.min_connections = 1;
            }
            if (String(this.config.scaling.max_connections || '').trim() === '' || Number(this.config.scaling.max_connections) === -1) {
                this.config.scaling.max_connections = null;
            }
            const scalingMode = String(this.config.scaling.mode || 'AUTO').trim().toUpperCase();
            if (!['AUTO', 'BOUNDED', 'FIXED'].includes(scalingMode)) {
                this.config.scaling.mode = 'AUTO';
            }

            // Initialize guardrails (used by AUTO and BOUNDED modes)
            if (!this.config.guardrails || typeof this.config.guardrails !== 'object') {
                this.config.guardrails = {};
            }
            // Migrate legacy autoscale_* fields to guardrails
            if (this.config.autoscale_max_cpu_percent != null && this.config.guardrails.max_cpu_percent == null) {
                this.config.guardrails.max_cpu_percent = Number(this.config.autoscale_max_cpu_percent);
            }
            if (this.config.autoscale_max_memory_percent != null && this.config.guardrails.max_memory_percent == null) {
                this.config.guardrails.max_memory_percent = Number(this.config.autoscale_max_memory_percent);
            }
            // Set defaults for guardrails
            if (this.config.guardrails.enabled == null) {
                this.config.guardrails.enabled = true;
            }
            if (!Number.isFinite(Number(this.config.guardrails.max_cpu_percent))) {
                this.config.guardrails.max_cpu_percent = 80;
            }
            if (!Number.isFinite(Number(this.config.guardrails.max_memory_percent))) {
                this.config.guardrails.max_memory_percent = 85;
            }

            const isPg = this.isPostgresFamilyTableType(this.config.table_type);
            const defaults = isPg
                ? {
                    custom_point_lookup_query: 'SELECT * FROM {table} WHERE id = $1',
                    custom_range_scan_query: 'SELECT * FROM {table} WHERE id BETWEEN $1 AND $2 LIMIT 100',
                    custom_insert_query: 'INSERT INTO {table} (id, data, timestamp) VALUES ($1, $2, $3)',
                    custom_update_query: 'UPDATE {table} SET data = $1, timestamp = $2 WHERE id = $3',
                }
                : {
                    custom_point_lookup_query: 'SELECT * FROM {table} WHERE id = ?',
                    custom_range_scan_query: 'SELECT * FROM {table} WHERE id BETWEEN ? AND ? + 100 LIMIT 100',
                    custom_insert_query: 'INSERT INTO {table} (id, data, timestamp) VALUES (?, ?, CURRENT_TIMESTAMP)',
                    custom_update_query: 'UPDATE {table} SET data = ?, timestamp = CURRENT_TIMESTAMP WHERE id = ?',
                };

            // Backfill SQL strings if missing.
            for (const k of ['custom_point_lookup_query', 'custom_range_scan_query', 'custom_insert_query', 'custom_update_query']) {
                if (!String(this.config[k] || '').trim()) {
                    this.config[k] = defaults[k];
                }
            }

            // Backfill weight fields if missing (use MIXED if everything is zero).
            const pctKeys = ['custom_point_lookup_pct', 'custom_range_scan_pct', 'custom_insert_pct', 'custom_update_pct'];
            for (const k of pctKeys) {
                const n = Number(this.config[k]);
                this.config[k] = Number.isFinite(n) ? n : 0;
            }
            if (this.mixTotal() === 0) {
                this.applyMixPreset('MIXED');
            } else {
                this.syncMixPresetFromWeights();
            }

            // Backfill target keys to -1 (disabled).
            for (const k of [
                'target_point_lookup_p95_latency_ms',
                'target_range_scan_p95_latency_ms',
                'target_insert_p95_latency_ms',
                'target_update_p95_latency_ms',
                'target_point_lookup_p99_latency_ms',
                'target_range_scan_p99_latency_ms',
                'target_insert_p99_latency_ms',
                'target_update_p99_latency_ms',
                'target_point_lookup_error_rate_pct',
                'target_range_scan_error_rate_pct',
                'target_insert_error_rate_pct',
                'target_update_error_rate_pct',
            ]) {
                if (this.config[k] == null || String(this.config[k]).trim() === '') {
                    this.config[k] = -1;
                }
            }

        },

        nextTickAsync() {
            return new Promise((resolve) => this.$nextTick(resolve));
        },

        forceSelectValue(id, value) {
            const el = document.getElementById(id);
            if (!el) return;
            el.value = String(value || '');
        },

        formatWarehouseOption(wh) {
            // Format: WH_NAME (Gen1/2, Size, MCW 1-X?, QAS?)
            const gen = wh.resource_constraint === 'STANDARD_GEN_2' ? 'Gen2' : 'Gen1';
            let parts = [gen, wh.size];
            
            // Add MCW only if multi-cluster is enabled (max > 1)
            if (wh.max_cluster_count > 1) {
                parts.push(`MCW ${wh.min_cluster_count}-${wh.max_cluster_count}`);
            }
            
            // Add QAS only if enabled
            if (wh.enable_query_acceleration) {
                parts.push('QAS');
            }
            
            return `${wh.name} (${parts.join(', ')})`;
        },

        async onTableTypeChanged() {
            const tableType = String(this.config.table_type || '').trim().toUpperCase();
            const isPostgres = tableType === 'POSTGRES';

            if (isPostgres) {
                // Avoid persisting/using a Snowflake execution warehouse for Postgres templates.
                this.config.warehouse_name = '';
                this.selectedWarehouseDetails = null;
            }

            // Interactive tables do NOT support DML (INSERT, UPDATE, DELETE).
            // Only INSERT OVERWRITE is allowed (not supported in benchmark workloads).
            // Auto-switch to READ_ONLY and zero out INSERT/UPDATE.
            if (this.isInteractiveTable(tableType)) {
                this.config.custom_insert_pct = 0;
                this.config.custom_update_pct = 0;
                this.config.custom_insert_query = '';
                this.config.custom_update_query = '';
                this.applyMixPreset('READ_ONLY');
            }

            await this.loadCatalog();
        },

        objectDisplayName(obj) {
            // Generate display name with type prefix: "STD: TABLE_NAME", "HYB: TABLE_NAME", etc.
            const detectedType = String(obj?.detected_type || '').toUpperCase();
            const name = obj?.name || '';
            let prefix = '';
            if (detectedType === 'STANDARD') prefix = 'STD:';
            else if (detectedType === 'HYBRID') prefix = 'HYB:';
            else if (detectedType === 'DYNAMIC') prefix = 'DYN:';
            else if (detectedType === 'INTERACTIVE') prefix = 'INT:';
            else if (detectedType === 'VIEW') prefix = 'VIEW:';
            else if (detectedType === 'TABLE') prefix = 'TBL:';  // For Postgres tables
            return prefix ? `${prefix} ${name}` : name;
        },

        onTableSelected() {
            // When user selects a table, auto-set config.table_type from detected_type
            const tableName = String(this.config.table_name || '').trim().toUpperCase();
            if (!tableName) {
                this.detectedTableType = null;
                return;
            }

            const obj = (this.availableObjects || []).find(
                (o) => String(o?.name || '').toUpperCase() === tableName
            );

            if (!obj) {
                this.detectedTableType = null;
                return;
            }

            const detectedType = String(obj.detected_type || '').toUpperCase();
            this.detectedTableType = detectedType;

            // Map detected_type to config.table_type
            // For Snowflake: STANDARD, HYBRID, DYNAMIC, INTERACTIVE, VIEW -> use as table_type (VIEW uses STANDARD)
            // For Postgres: TABLE, VIEW -> keep current Postgres table_type
            const isPostgresFilter = this.objectTypeFilter === 'POSTGRES';
            
            if (isPostgresFilter) {
                // Keep the Postgres table_type, don't change it
                return;
            }

            // For Snowflake objects, set table_type based on detected type
            if (detectedType === 'HYBRID') {
                this.config.table_type = 'HYBRID';
            } else if (detectedType === 'DYNAMIC') {
                this.config.table_type = 'DYNAMIC';
                // Dynamic tables don't support DML (they're materialized views)
                this.config.custom_insert_pct = 0;
                this.config.custom_update_pct = 0;
                this.applyMixPreset('READ_ONLY');
            } else if (detectedType === 'INTERACTIVE') {
                this.config.table_type = 'INTERACTIVE';
                // Interactive tables don't support DML in this benchmark tool
                this.config.custom_insert_pct = 0;
                this.config.custom_update_pct = 0;
                this.applyMixPreset('READ_ONLY');
            } else {
                // STANDARD or VIEW - use STANDARD table_type
                this.config.table_type = 'STANDARD';
            }
        },

        // Called when the connection dropdown changes
        async onConnectionChanged() {
            const conn = this.getSelectedConnection();
            if (!conn) {
                // No connection selected - reset everything
                this.objectTypeFilter = 'ALL_SNOWFLAKE';
                this.config.table_type = 'STANDARD';
                this.config.database = '';
                this.config.schema = '';
                this.config.table_name = '';
                this.availableDatabases = [];
                this.availableSchemas = [];
                this.availableObjects = [];
                return;
            }

            const isPostgres = conn.connection_type === 'POSTGRES';

            // Clear existing selections when switching connections
            this.config.database = '';
            this.config.schema = '';
            this.config.table_name = '';
            this.availableDatabases = [];
            this.availableSchemas = [];
            this.availableObjects = [];
            this.detectedTableType = null;

            if (isPostgres) {
                // For Postgres connections, set filter and table type to POSTGRES
                this.objectTypeFilter = 'POSTGRES';
                this.config.table_type = 'POSTGRES';
                this.config.warehouse_name = '';
                this.selectedWarehouseDetails = null;
            } else {
                // For Snowflake connections, default to ALL_SNOWFLAKE filter
                this.objectTypeFilter = 'ALL_SNOWFLAKE';
                this.config.table_type = 'STANDARD';
            }

            // Reload the catalog for the new connection
            await this.loadCatalog();
        },

        async onObjectTypeFilterChanged() {
            const filter = String(this.objectTypeFilter || 'ALL_SNOWFLAKE').toUpperCase();
            const isPostgres = filter === 'POSTGRES';
            const wasPostgres = this.isPostgresFamilyTableType(this.config.table_type);
            const isConnectionSwitch = isPostgres !== wasPostgres;

            // Set table_type for Postgres connections
            if (isPostgres) {
                this.config.table_type = filter;
                this.config.warehouse_name = '';
                this.selectedWarehouseDetails = null;
            } else {
                // For Snowflake filters, set default table_type (will be auto-detected on selection)
                this.config.table_type = 'STANDARD';
            }

            // Only clear database/schema when switching between Postgres and Snowflake
            // Keep them when switching between Snowflake table types
            if (isConnectionSwitch) {
                this.config.database = '';
                this.config.schema = '';
                this.availableDatabases = [];
                this.availableSchemas = [];
            }
            
            // Always clear table selection and reload objects
            this.config.table_name = '';
            this.detectedTableType = null;
            this.availableObjects = [];

            await this.loadCatalog();
        },

        async loadCatalog() {
            // Capture saved values before any async operations (x-model can clear values when options aren't rendered yet)
            const savedDatabase = String(this.config.database || '').trim();
            const savedSchema = String(this.config.schema || '').trim();
            const savedTableName = String(this.config.table_name || '').trim();
            const isEditingTemplate = this.mode === 'edit' || this.mode === 'view';

            // Don't load catalog until a connection is selected
            if (!this.config.connection_id) {
                this.availableDatabases = [];
                this.availableSchemas = [];
                this.availableObjects = [];
                return;
            }

            try {
                const t = String(this.config.table_type || '').trim().toLowerCase();
                let url = `/api/catalog/databases?table_type=${encodeURIComponent(t)}`;
                // Pass connection_id for future multi-connection support
                if (this.config.connection_id) {
                    url += `&connection_id=${encodeURIComponent(this.config.connection_id)}`;
                }
                const dbResp = await fetch(url);
                if (!dbResp.ok) {
                    const errPayload = await dbResp.json().catch(() => ({}));
                    const detail = errPayload?.detail || `HTTP ${dbResp.status}`;
                    window.toast.error(`Failed to load databases: ${detail}`);
                    this.availableDatabases = [];
                    return;
                }
                const dbs = await dbResp.json();
                this.availableDatabases = dbs || [];

                const normalize = (v) => String(v || '').trim().toUpperCase();

                // Pick desired database:
                // - If editing template, try to match saved database
                // - Else fall back to first available
                let desiredDb = '';
                const selectedNorm = normalize(savedDatabase);
                if (selectedNorm) {
                    const match = (this.availableDatabases || []).find(
                        (d) => normalize(d?.name) === selectedNorm,
                    );
                    desiredDb = match?.name || '';
                }
                if (!desiredDb && this.availableDatabases.length > 0 && !isEditingTemplate) {
                    // Only auto-select first database for new templates
                    desiredDb = this.availableDatabases[0].name;
                }

                // Important: set x-model value only after options are rendered, otherwise the browser may keep
                // showing the placeholder (and can even sync "" back into the model).
                await this.nextTickAsync();
                await this.nextTickAsync();

                this.config.database = desiredDb;

                // Force DOM select value to match once options exist.
                await this.nextTickAsync();
                this.forceSelectValue('database-select', desiredDb);

                // Restore saved selections in case x-model cleared them while options were unavailable.
                if (savedSchema) {
                    this.config.schema = savedSchema;
                }
                if (savedTableName) {
                    this.config.table_name = savedTableName;
                }

                // Pass preserveSelection=true when editing to keep saved schema/table.
                await this.onDatabaseChanged(isEditingTemplate);
            } catch (e) {
                console.warn('Failed to load catalog:', e);
                window.toast.error('Failed to load catalog: ' + (e?.message || e));
                this.availableDatabases = [];
                this.availableSchemas = [];
                this.availableObjects = [];
                // Don't clear saved selections on failure in edit/view; allow the user to retry by changing type/db.
                if (!isEditingTemplate) {
                    this.config.database = '';
                    this.config.schema = '';
                    this.config.table_name = '';
                }
            }
        },

        async onDatabaseChanged(preserveSelection = false) {
            const savedSchema = String(this.config.schema || '').trim();
            const savedTableName = String(this.config.table_name || '').trim();
            this.availableSchemas = [];
            this.availableObjects = [];

            const db = String(this.config.database || '').trim();
            if (!db) {
                this.config.schema = '';
                this.config.table_name = '';
                return;
            }

            try {
                const t = String(this.config.table_type || '').trim().toLowerCase();
                let url =
                    `/api/catalog/schemas?table_type=${encodeURIComponent(t)}` +
                    `&database=${encodeURIComponent(db)}`;
                // Pass connection_id for Postgres connections
                if (this.config.connection_id) {
                    url += `&connection_id=${encodeURIComponent(this.config.connection_id)}`;
                }
                const resp = await fetch(url);
                if (!resp.ok) {
                    const errPayload = await resp.json().catch(() => ({}));
                    const detail = errPayload?.detail || `HTTP ${resp.status}`;
                    window.toast.error(`Failed to load schemas: ${detail}`);
                    this.availableSchemas = [];
                    this.availableObjects = [];
                    if (!preserveSelection) {
                        this.config.schema = '';
                        this.config.table_name = '';
                    }
                    return;
                }
                const schemas = await resp.json();
                this.availableSchemas = schemas || [];

                const normalize = (v) => String(v || '').trim().toUpperCase();
                const curNorm = normalize(savedSchema);
                const match = (this.availableSchemas || []).find(
                    (s) => normalize(s?.name) === curNorm,
                );

                // Important: set x-model value only after options are rendered.
                await this.nextTickAsync();
                await this.nextTickAsync();

                if (match) {
                    // Match found: use exact name from API (fixes case mismatch with dropdown)
                    this.config.schema = match.name;
                } else if (!preserveSelection && this.availableSchemas.length > 0) {
                    // No match and not preserving: fall back to first available
                    this.config.schema = this.availableSchemas[0].name;
                } else {
                    // No match found: clear (saved schema doesn't exist anymore)
                    this.config.schema = '';
                }

                // Force DOM select value to match once options exist.
                await this.nextTickAsync();
                this.forceSelectValue('schema-select', this.config.schema);

                // Restore saved table selection before loading objects (in case x-model cleared it).
                if (savedTableName) {
                    this.config.table_name = savedTableName;
                }

                await this.onSchemaChanged(preserveSelection);
            } catch (e) {
                console.warn('Failed to load schemas:', e);
                window.toast.error('Failed to load schemas: ' + (e?.message || e));
                this.availableSchemas = [];
                this.availableObjects = [];
                if (!preserveSelection) {
                    this.config.schema = '';
                    this.config.table_name = '';
                }
            }
        },

        async onSchemaChanged(preserveSelection = false) {
            const savedTableName = String(this.config.table_name || '').trim();
            this.availableObjects = [];
            this.detectedTableType = null;

            const db = String(this.config.database || '').trim();
            const schema = String(this.config.schema || '').trim();
            if (!db || !schema) {
                this.config.table_name = '';
                return;
            }

            try {
                const t = String(this.config.table_type || '').trim().toLowerCase();
                let url =
                    `/api/catalog/objects?table_type=${encodeURIComponent(t)}` +
                    `&database=${encodeURIComponent(db)}` +
                    `&schema=${encodeURIComponent(schema)}`;
                
                // Pass connection_id for Postgres connections
                if (this.config.connection_id) {
                    url += `&connection_id=${encodeURIComponent(this.config.connection_id)}`;
                }
                
                // Add filter_type param for Snowflake when a specific filter is selected
                const filter = String(this.objectTypeFilter || 'ALL_SNOWFLAKE').toUpperCase();
                const isPostgres = filter === 'POSTGRES';
                if (!isPostgres && filter !== 'ALL_SNOWFLAKE') {
                    url += `&filter_type=${encodeURIComponent(filter)}`;
                }
                
                const resp = await fetch(url);
                if (!resp.ok) {
                    const errPayload = await resp.json().catch(() => ({}));
                    const detail = errPayload?.detail || `HTTP ${resp.status}`;
                    window.toast.error(`Failed to load tables: ${detail}`);
                    this.availableObjects = [];
                    this.config.table_name = '';
                    return;
                }
                const objs = await resp.json();
                this.availableObjects = objs || [];

                const normalize = (v) => String(v || '').trim().toUpperCase();
                const curNorm = normalize(savedTableName);
                const match = (this.availableObjects || []).find(
                    (o) => normalize(o?.name) === curNorm,
                );

                // Important: set x-model value only after options are rendered.
                await this.nextTickAsync();
                await this.nextTickAsync();

                if (match) {
                    // Match found: use exact name from API (fixes case mismatch with dropdown)
                    this.config.table_name = match.name;
                    // Set detected type for the matched table
                    this.detectedTableType = String(match.detected_type || '').toUpperCase();
                } else {
                    // No match found: clear (saved table doesn't exist or not preserving)
                    // Do not auto-select a table - require explicit user selection
                    this.config.table_name = '';
                }

                // Force DOM select value to match once options exist.
                await this.nextTickAsync();
                this.forceSelectValue('table-select', this.config.table_name);
            } catch (e) {
                console.warn('Failed to load objects:', e);
                window.toast.error('Failed to load tables: ' + (e?.message || e));
                this.availableObjects = [];
                this.config.table_name = '';
            }
        },
        
        async init() {
            this.isInitializing = true;
            this.error = null;

            // Keep mix_preset in sync with weight edits.
            this.$watch('config.custom_point_lookup_pct', () => this.syncMixPresetFromWeights());
            this.$watch('config.custom_range_scan_pct', () => this.syncMixPresetFromWeights());
            this.$watch('config.custom_insert_pct', () => this.syncMixPresetFromWeights());
            this.$watch('config.custom_update_pct', () => this.syncMixPresetFromWeights());

            // Load mode UX:
            // - When switching into auto-scale mode, default Max Connections to -1 (no user cap)
            //   unless the user already set a non-default cap.
            // - When switching back to CONCURRENCY mode, ensure Concurrent Connections is >= 1.
            this._prevLoadMode = String(this.config.load_mode || 'CONCURRENCY').trim().toUpperCase();
            this.$watch('config.load_mode', (v) => {
                const next = String(v || 'CONCURRENCY').trim().toUpperCase();
                const prev = String(this._prevLoadMode || 'CONCURRENCY').trim().toUpperCase();
                if (next === 'QPS' && prev !== 'QPS') {
                    const maxConnRaw = this.config.scaling?.max_connections;
                    const maxConnSet = !(maxConnRaw == null || String(maxConnRaw).trim() === '');
                    if (!maxConnSet) {
                        const cur = Number(this.config.concurrent_connections);
                        if (!Number.isFinite(cur) || cur === 10) {
                            this.config.concurrent_connections = -1;
                            this.config.scaling.max_connections = null;
                        } else if (cur > 0) {
                            this.config.scaling.max_connections = cur;
                        }
                    }
                }
                if (next !== 'QPS' && prev === 'QPS') {
                    // FIND_MAX doesn't use concurrent_connections - it discovers the max dynamically
                    if (next === 'FIND_MAX_CONCURRENCY') {
                        this.config.concurrent_connections = null;
                    } else {
                        const cur = Number(this.config.concurrent_connections);
                        if (!Number.isFinite(cur) || cur < 1) {
                            this.config.concurrent_connections = 10;
                        }
                    }
                }
                // When switching TO FIND_MAX from any mode, clear concurrent_connections
                if (next === 'FIND_MAX_CONCURRENCY' && prev !== 'FIND_MAX_CONCURRENCY') {
                    this.config.concurrent_connections = null;
                }
                this._prevLoadMode = next;
            });

            this.$watch('config.scaling.max_connections', (v) => {
                const mode = String(this.config.load_mode || 'CONCURRENCY').trim().toUpperCase();
                if (mode !== 'QPS') return;
                const next = Number(v);
                if (!Number.isFinite(next) || next < 1) {
                    this.config.concurrent_connections = -1;
                    return;
                }
                this.config.concurrent_connections = Math.max(1, Math.round(next));
            });

            // Enforce 200 per-worker connection limit with immediate feedback
            const MAX_CONNS_PER_WORKER = 200;
            this.$watch('config.scaling.min_connections', (v) => {
                const scalingMode = String(this.config.scaling?.mode || 'AUTO').toUpperCase();
                if (scalingMode !== 'FIXED' && scalingMode !== 'BOUNDED') return;
                const val = Number(v);
                if (Number.isFinite(val) && val > MAX_CONNS_PER_WORKER) {
                    window.toast.error(`Threads/Worker capped at ${MAX_CONNS_PER_WORKER}. Each connection spawns multiple internal threads.`);
                    this.config.scaling.min_connections = MAX_CONNS_PER_WORKER;
                }
            });
            this.$watch('config.scaling.max_connections', (v, prev) => {
                const scalingMode = String(this.config.scaling?.mode || 'AUTO').toUpperCase();
                if (scalingMode !== 'BOUNDED') return;
                const val = Number(v);
                if (Number.isFinite(val) && val > MAX_CONNS_PER_WORKER) {
                    window.toast.error(`Max Threads/Worker capped at ${MAX_CONNS_PER_WORKER}. Each connection spawns multiple internal threads.`);
                    this.config.scaling.max_connections = MAX_CONNS_PER_WORKER;
                }
            });

            // Initialize guardrails defaults when switching to non-FIXED mode
            this.$watch('config.scaling.mode', (v) => {
                const mode = String(v || 'AUTO').toUpperCase();
                if (mode === 'FIXED') return;
                if (!this.config.guardrails) {
                    this.config.guardrails = {};
                }
                if (!Number.isFinite(Number(this.config.guardrails.max_cpu_percent || 0))) {
                    this.config.guardrails.max_cpu_percent = 80;
                }
                if (!Number.isFinite(Number(this.config.guardrails.max_memory_percent || 0))) {
                    this.config.guardrails.max_memory_percent = 85;
                }
            });

            // Check URL params for mode
            const urlParams = new URLSearchParams(window.location.search);
            const urlMode = urlParams.get('mode');
            if (urlMode === 'new') {
                this.mode = 'new';
            }
            if (urlMode === 'view') {
                this.mode = 'view';
                this.isReadOnly = true;
            }

            // Prefer URL-based editing (robust across reloads / desktop wrapper).
            const templateId = urlParams.get('template_id');
            if (templateId) {
                try {
                    const resp = await fetch(`/api/templates/${encodeURIComponent(templateId)}`);
                    if (resp.ok) {
                        const template = await resp.json();
                        this.loadedTemplate = template;
                        this.hasResults = (template.usage_count || 0) > 0;
                        // If template has results, it cannot be edited (force read-only).
                        // If URL mode explicitly requests view, also force read-only.
                        if (this.hasResults || this.mode === 'view') {
                            this.mode = 'view';
                            this.isReadOnly = true;
                        } else {
                            this.mode = 'edit';
                            this.isReadOnly = false;
                        }
                        // Deep merge nested objects to preserve defaults for scaling and guardrails
                        const templateConfig = template.config || {};
                        const defaultScaling = { ...this.config.scaling };
                        const defaultGuardrails = { ...this.config.guardrails };
                        this.config = { ...this.config, ...templateConfig };
                        // Restore defaults for nested objects, then overlay saved values
                        this.config.scaling = { ...defaultScaling, ...(templateConfig.scaling || {}) };
                        this.config.guardrails = { ...defaultGuardrails, ...(templateConfig.guardrails || {}) };
                        if (this.config.warehouse_name) {
                            this.config.warehouse_name = String(this.config.warehouse_name).trim();
                        }
                        // Default: if not present, treat as TRUE.
                        // Coerce to a boolean for the checkbox UI.
                        if (this.config.use_cached_result == null) {
                            this.config.use_cached_result = true;
                        } else {
                            const v = String(this.config.use_cached_result).trim().toLowerCase();
                            this.config.use_cached_result = !['0', 'false', 'no', 'off'].includes(v);
                        }
                        // Default use_pgbouncer to FALSE for Postgres connections.
                        // PgBouncer may not be available on all instances.
                        // Coerce to a boolean for the checkbox UI.
                        if (this.config.use_pgbouncer == null) {
                            this.config.use_pgbouncer = false;
                        } else {
                            const v = String(this.config.use_pgbouncer).trim().toLowerCase();
                            this.config.use_pgbouncer = !['0', 'false', 'no', 'off'].includes(v);
                        }
                        this.ensureCanonicalWorkloadConfig();
                        this.config.template_name = template.template_name;
                        this.config.description = template.description;
                        // Initialize objectTypeFilter based on loaded template's table_type
                        const tt = String(this.config.table_type || '').toUpperCase();
                        if (tt === 'POSTGRES') {
                            this.objectTypeFilter = tt;
                        } else {
                            // For Snowflake types, default to ALL_SNOWFLAKE (type will be auto-detected)
                            this.objectTypeFilter = 'ALL_SNOWFLAKE';
                        }
                        this.aiPrepResult = this.aiPrepStatusFromConfig('Loaded from template');
                        this.aiPrepError = null;
                    } else {
                        const payload = await resp.json().catch(() => ({}));
                        const detail = payload && payload.detail ? payload.detail : null;
                        this.error =
                            (detail && (detail.message || detail.detail || detail)) ||
                            `Failed to load template (HTTP ${resp.status})`;
                        console.warn('Failed to load template by id:', templateId, resp.status, this.error);
                    }
                } catch (error) {
                    console.error('Failed to load template by id:', error);
                    this.error = error?.message || String(error);
                }
            }

            // If this is a Postgres-based template type, clear warehouse fields to avoid
            // accidentally persisting/using the results warehouse as an "execution" warehouse.
            if (this.config.table_type === 'POSTGRES') {
                this.config.warehouse_name = '';
                this.selectedWarehouseDetails = null;
            }

            // Load warehouses before enabling the form so users don't start editing
            // and then have dropdowns/details change underneath them.
            try {
                await this.loadConnections();
                await this.loadWarehouses();
                await this.loadCatalog();
            } finally {
                this.snapshotConfig();
                this.isInitializing = false;
            }
        },

        async loadConnections() {
            try {
                const resp = await fetch('/api/connections/');
                if (resp.ok) {
                    const data = await resp.json();
                    this.availableConnections = data.connections || [];
                    
                    // Capture the saved connection_id before any modifications
                    const savedConnectionId = this.config.connection_id || '';
                    
                    // If we have a saved connection_id from template, verify it exists
                    // and set the objectTypeFilter accordingly
                    if (savedConnectionId) {
                        const match = this.availableConnections.find(
                            c => c.connection_id === savedConnectionId
                        );
                        if (!match) {
                            // Connection no longer exists - clear it
                            console.warn('Saved connection_id not found:', savedConnectionId);
                            this.config.connection_id = '';
                        } else {
                            // Set objectTypeFilter based on the loaded connection's type
                            if (match.connection_type === 'POSTGRES') {
                                this.objectTypeFilter = 'POSTGRES';
                                this.config.table_type = 'POSTGRES';
                            } else {
                                // Keep existing objectTypeFilter for Snowflake (could be HYBRID, STANDARD, etc.)
                                // but ensure it's not POSTGRES
                                if (this.objectTypeFilter === 'POSTGRES') {
                                    this.objectTypeFilter = 'ALL_SNOWFLAKE';
                                }
                            }
                        }
                    }
                    
                    // If no connection selected and only one exists, auto-select it
                    if (!this.config.connection_id && this.availableConnections.length === 1) {
                        this.config.connection_id = this.availableConnections[0].connection_id;
                        // Set the appropriate filter based on connection type
                        const conn = this.availableConnections[0];
                        if (conn.connection_type === 'POSTGRES') {
                            this.objectTypeFilter = 'POSTGRES';
                            this.config.table_type = 'POSTGRES';
                        }
                    }
                    
                    // Wait for Alpine to render the options, then force the select value
                    await this.nextTickAsync();
                    await this.nextTickAsync();
                    
                    // Restore the connection_id (x-model may have cleared it while options were loading)
                    if (savedConnectionId && this.availableConnections.find(c => c.connection_id === savedConnectionId)) {
                        this.config.connection_id = savedConnectionId;
                    }
                    
                    // Force DOM select to match
                    await this.nextTickAsync();
                    this.forceSelectValue('connection-select', this.config.connection_id);
                    
                } else {
                    console.warn('Failed to load connections:', resp.status);
                    window.toast.error('Failed to load connections');
                }
            } catch (e) {
                console.error('Error loading connections:', e);
                window.toast.error('Error loading connections: ' + (e?.message || e));
            }
        },
        
        async loadWarehouses() {
            try {
                const [warehousesResp, infoResp] = await Promise.all([
                    // Include all warehouses so we can display (and warn about) templates
                    // that were previously saved with the results warehouse.
                    fetch('/api/warehouses/'),
                    fetch('/api/info'),
                ]);
                if (warehousesResp.ok) {
                    const allWarehouses = await warehousesResp.json();
                    const info = infoResp.ok ? await infoResp.json() : {};
                    this.resultsWarehouse = String(info.results_warehouse || '').trim().toUpperCase() || null;

                    this.availableWarehouses = allWarehouses || [];

                    const normalize = (v) => String(v || '').trim().toUpperCase();

                    // Choose desired warehouse:
                    // - If template provided one and it exists, use canonical option value.
                    // - If it doesn't exist, require explicit user selection.
                    let desiredWarehouseName = '';
                    const selectedNorm = normalize(this.config.warehouse_name);
                    if (selectedNorm) {
                        const match = (this.availableWarehouses || []).find(
                            (w) => normalize(w?.name) === selectedNorm,
                        );
                        desiredWarehouseName = match?.name || '';
                    }

                    // Important: set x-model value only after options are rendered,
                    // otherwise the browser may keep showing the placeholder even though
                    // the value is set and details load correctly.
                    await this.nextTickAsync();
                    // Some browsers require an additional tick before <select> option values are stable.
                    await this.nextTickAsync();

                    this.config.warehouse_name = desiredWarehouseName;

                    // Force DOM select value to match (in case x-model updates before options settle).
                    await this.nextTickAsync();
                    const selectEl = document.getElementById('warehouse-select');
                    if (selectEl) {
                        selectEl.value = desiredWarehouseName;
                    }

                    if (!this.config.warehouse_name) {
                        this.selectedWarehouseDetails = null;
                        return;
                    }
                    await this.loadWarehouseDetails();
                } else {
                    const payload = await warehousesResp.json().catch(() => ({}));
                    const detail = payload && payload.detail ? payload.detail : null;
                    this.error =
                        (detail && (detail.message || detail.detail || detail)) ||
                        `Failed to load warehouses (HTTP ${warehousesResp.status})`;
                    console.error('Failed to load warehouses', this.error);
                }
            } catch (error) {
                console.error('Error loading warehouses:', error);
                this.error = error?.message || String(error);
            }
        },
        
        async loadWarehouseDetails() {
            if (!this.config.warehouse_name) {
                this.selectedWarehouseDetails = null;
                return;
            }
            
            try {
                const response = await fetch(
                    `/api/warehouses/${encodeURIComponent(this.config.warehouse_name)}`,
                );
                if (response.ok) {
                    this.selectedWarehouseDetails = await response.json();
                    
                    // Normalize warehouse size from Snowflake format (e.g., "X-Large") to our format (e.g., "XLARGE")
                    const sizeMap = {
                        'X-Small': 'XSMALL',
                        'Small': 'SMALL',
                        'Medium': 'MEDIUM',
                        'Large': 'LARGE',
                        'X-Large': 'XLARGE',
                        '2X-Large': '2XLARGE',
                        '3X-Large': '3XLARGE',
                        '4X-Large': '4XLARGE'
                    };
                    
                    // Auto-populate warehouse configuration
                    this.config.warehouse_size = sizeMap[this.selectedWarehouseDetails.size] || this.selectedWarehouseDetails.size;
                    this.config.multi_cluster = this.selectedWarehouseDetails.max_cluster_count > 1;
                    this.config.min_clusters = this.selectedWarehouseDetails.min_cluster_count;
                    this.config.max_clusters = this.selectedWarehouseDetails.max_cluster_count;
                    this.config.scaling_policy = this.selectedWarehouseDetails.scaling_policy || 'STANDARD';
                } else {
                    console.error('Failed to load warehouse details');
                }
            } catch (error) {
                console.error('Error loading warehouse details:', error);
            }
        },
        
        clearTemplate() {
            this.loadedTemplate = null;
            this.resetConfig();
        },
        
        addIndex() {
            // Removed: table creation (including indexes) is no longer supported.
        },
        
        removeIndex(idx) {
            // Removed: table creation (including indexes) is no longer supported.
        },
        
        async submitTest() {
            await this._saveTemplate({ prepareAfterSave: false });
        },

        async saveAndPrepare() {
            if (this.saveAndPrepareLoading) return;
            this.saveAndPrepareLoading = true;
            try {
                await this._saveTemplate({ prepareAfterSave: true });
            } finally {
                this.saveAndPrepareLoading = false;
            }
        },

        async _saveTemplate({ prepareAfterSave = false } = {}) {
            if (this.isSaving) {
                return;
            }
            if (this.isReadOnly) {
                window.toast.warning('Template is read-only and cannot be updated.');
                return;
            }
            if (!this.config.template_name) {
                window.toast.warning('Please provide a template name');
                return;
            }
            // Canonical: templates always persist CUSTOM SQL + weights.
            this.ensureCanonicalWorkloadConfig();

            const total = this.mixTotal();
            if (total !== 100) {
                window.toast.warning(
                    `Mix percentages must sum to 100 (currently ${total}).`,
                );
                return;
            }

            // Match server validation: SQL is required when a weight > 0.
            const requiredPairs = [
                ['custom_point_lookup_pct', 'custom_point_lookup_query', 'Point Lookup'],
                ['custom_range_scan_pct', 'custom_range_scan_query', 'Range Scan'],
                ['custom_insert_pct', 'custom_insert_query', 'Insert'],
                ['custom_update_pct', 'custom_update_query', 'Update'],
            ];
            for (const [pctK, sqlK, label] of requiredPairs) {
                const pct = Number(this.config[pctK] || 0);
                const sql = String(this.config[sqlK] || '').trim();
                if (pct > 0 && !sql) {
                    window.toast.warning(`${label}: SQL is required when weight % > 0.`);
                    return;
                }
            }

            // Validate load mode.
            const loadMode = String(this.config.load_mode || 'CONCURRENCY').trim().toUpperCase();
            if (!['CONCURRENCY', 'QPS', 'FIND_MAX_CONCURRENCY'].includes(loadMode)) {
                window.toast.warning('Invalid load mode. Choose Fixed workers, Target throughput (QPS), or Find max.');
                return;
            }

            const scalingMode = String(this.config.scaling?.mode || 'AUTO').trim().toUpperCase();
            const minWorkers = Number(this.config.scaling?.min_workers || 1);
            const maxWorkersRaw = this.config.scaling?.max_workers;
            const maxWorkers =
                maxWorkersRaw == null || String(maxWorkersRaw).trim() === ''
                    ? null
                    : Number(maxWorkersRaw);
            const minC = Number(this.config.scaling?.min_connections || 1);
            const maxCRaw = this.config.scaling?.max_connections;
            const maxC =
                maxCRaw == null || String(maxCRaw).trim() === ''
                    ? null
                    : Number(maxCRaw);

            if (!Number.isFinite(minWorkers) || minWorkers < 1) {
                window.toast.warning('Min Workers must be >= 1.');
                return;
            }
            if (maxWorkers != null && (!Number.isFinite(maxWorkers) || maxWorkers < 1)) {
                window.toast.warning('Max Workers must be >= 1 or blank.');
                return;
            }
            if (maxWorkers != null && minWorkers > maxWorkers) {
                window.toast.warning('Min Workers must be <= Max Workers.');
                return;
            }
            if (!Number.isFinite(minC) || minC < 1) {
                window.toast.warning('Min Connections must be >= 1.');
                return;
            }
            if (maxC != null && (!Number.isFinite(maxC) || maxC < 1)) {
                window.toast.warning('Max Connections must be >= 1 or blank.');
                return;
            }
            if (maxC != null && minC > maxC) {
                window.toast.warning('Min Connections must be <= Max Connections.');
                return;
            }

            // Enforce 200 per-worker connection limit for BOUNDED and FIXED modes.
            // Each Snowflake connection spawns 3-4 internal threads, so 200 connections
            // = 600-800 threads per worker. Higher values risk OS thread exhaustion.
            const MAX_CONNECTIONS_PER_WORKER = 200;
            if (scalingMode === 'BOUNDED' || scalingMode === 'FIXED') {
                if (minC > MAX_CONNECTIONS_PER_WORKER) {
                    window.toast.error(`Threads/Worker cannot exceed ${MAX_CONNECTIONS_PER_WORKER}. Each connection spawns multiple internal threads.`);
                    return;
                }
                if (maxC != null && maxC > MAX_CONNECTIONS_PER_WORKER) {
                    window.toast.error(`Max Threads/Worker cannot exceed ${MAX_CONNECTIONS_PER_WORKER}. Each connection spawns multiple internal threads.`);
                    return;
                }
            }

            if (scalingMode === 'FIXED') {
                if (this.config.scaling?.min_workers == null || String(this.config.scaling?.min_workers).trim() === '') {
                    window.toast.warning('FIXED mode requires Min Workers.');
                    return;
                }
                if (this.config.scaling?.min_connections == null || String(this.config.scaling?.min_connections).trim() === '') {
                    window.toast.warning('FIXED mode requires Min Connections.');
                    return;
                }
            }

            if (loadMode === 'FIND_MAX_CONCURRENCY') {
                const startC = Number(this.config.start_concurrency || 5);
                const increment = Number(this.config.concurrency_increment || 10);
                const stepDur = Number(this.config.step_duration_seconds || 30);
                const maxC = Number(this.config.concurrent_connections || 100);
                if (!Number.isFinite(startC) || startC < 1) {
                    window.toast.warning('Start Concurrency must be >= 1.');
                    return;
                }
                if (!Number.isFinite(increment) || increment < 1) {
                    window.toast.warning('Concurrency Increment must be >= 1.');
                    return;
                }
                if (!Number.isFinite(stepDur) || stepDur < 10) {
                    window.toast.warning('Step Duration must be >= 10 seconds.');
                    return;
                }
                if (!Number.isFinite(maxC) || maxC < startC) {
                    window.toast.warning('Max Connections must be >= Start Concurrency.');
                    return;
                }
            }

            if (loadMode === 'QPS') {
                const targetQps = Number(this.config.target_qps || 0);
                if (!Number.isFinite(targetQps) || targetQps <= 0) {
                    window.toast.warning('Target must be a positive number.');
                    return;
                }
            }

            // Validate connection limits for Postgres based on PgBouncer setting
            const isPostgresTableType = this.isPostgresFamilyTableType(this.config.table_type);
            if (isPostgresTableType) {
                const usePgBouncer = this.config.use_pgbouncer === true;
                // Direct PostgreSQL max_connections is typically 500
                // PgBouncer can handle up to 1000 client connections (multiplexed over ~497 server connections)
                const DIRECT_POSTGRES_MAX = 500;
                const PGBOUNCER_MAX = 1000;
                const connectionLimit = usePgBouncer ? PGBOUNCER_MAX : DIRECT_POSTGRES_MAX;

                // Calculate total connections based on load mode
                let totalConnections = 0;
                if (loadMode === 'CONCURRENCY') {
                    totalConnections = Number(this.config.concurrent_connections || 0);
                } else if (loadMode === 'FIND_MAX_CONCURRENCY') {
                    totalConnections = Number(this.config.concurrent_connections || 0);
                } else if (loadMode === 'QPS' && scalingMode === 'FIXED') {
                    // For QPS mode with FIXED scaling, calculate from workers × connections
                    totalConnections = minWorkers * minC;
                }

                if (totalConnections > connectionLimit) {
                    if (usePgBouncer) {
                        window.toast.warning(
                            `Total connections (${totalConnections}) exceeds PgBouncer client limit (${PGBOUNCER_MAX}). ` +
                            `Reduce the connection count.`
                        );
                    } else {
                        window.toast.warning(
                            `Total connections (${totalConnections}) exceeds PostgreSQL max_connections (${DIRECT_POSTGRES_MAX}). ` +
                            `Enable PgBouncer to support up to ${PGBOUNCER_MAX} connections.`
                        );
                    }
                    return;
                }
            }

            // Validate guardrails for non-FIXED modes (only if enabled)
            if (scalingMode !== 'FIXED' && this.config.guardrails?.enabled !== false) {
                const maxCpu = Number(this.config.guardrails?.max_cpu_percent || 0);
                const maxMem = Number(this.config.guardrails?.max_memory_percent || 0);
                if (!Number.isFinite(maxCpu) || maxCpu <= 0 || maxCpu > 100) {
                    window.toast.warning('Max CPU % must be within (0, 100].');
                    return;
                }
                if (!Number.isFinite(maxMem) || maxMem <= 0 || maxMem > 100) {
                    window.toast.warning('Max Memory % must be within (0, 100].');
                    return;
                }
            }

            // Validate targets (SLOs). Use -1 to disable a target.
            const weights = {
                POINT_LOOKUP: Number(this.config.custom_point_lookup_pct || 0),
                RANGE_SCAN: Number(this.config.custom_range_scan_pct || 0),
                INSERT: Number(this.config.custom_insert_pct || 0),
                UPDATE: Number(this.config.custom_update_pct || 0),
            };

            const targetKeys = {
                POINT_LOOKUP: {
                    p95: 'target_point_lookup_p95_latency_ms',
                    p99: 'target_point_lookup_p99_latency_ms',
                    err: 'target_point_lookup_error_rate_pct',
                    label: 'Point Lookup',
                },
                RANGE_SCAN: {
                    p95: 'target_range_scan_p95_latency_ms',
                    p99: 'target_range_scan_p99_latency_ms',
                    err: 'target_range_scan_error_rate_pct',
                    label: 'Range Scan',
                },
                INSERT: {
                    p95: 'target_insert_p95_latency_ms',
                    p99: 'target_insert_p99_latency_ms',
                    err: 'target_insert_error_rate_pct',
                    label: 'Insert',
                },
                UPDATE: {
                    p95: 'target_update_p95_latency_ms',
                    p99: 'target_update_p99_latency_ms',
                    err: 'target_update_error_rate_pct',
                    label: 'Update',
                },
            };

            const isFiniteNumber = (v) => Number.isFinite(Number(v));

            for (const kind of Object.keys(targetKeys)) {
                const weight = Number(weights[kind] || 0);
                if (weight <= 0) continue;

                const keys = targetKeys[kind];
                const p95 = Number(this.config[keys.p95] ?? -1);
                const p99 = Number(this.config[keys.p99] ?? -1);
                const err = Number(this.config[keys.err] ?? -1);

                const p95Enabled = isFiniteNumber(p95) && p95 >= 0;
                const p99Enabled = isFiniteNumber(p99) && p99 >= 0;
                const errEnabled = isFiniteNumber(err) && err >= 0;

                if (p95Enabled) {
                    if (p95 <= 0) {
                        window.toast.warning(
                            `${keys.label}: P95 target must be > 0 (ms), or -1 to disable.`,
                        );
                        return;
                    }
                }

                if (p99Enabled) {
                    if (p99 <= 0) {
                        window.toast.warning(
                            `${keys.label}: P99 target must be > 0 (ms), or -1 to disable.`,
                        );
                        return;
                    }
                }

                if (errEnabled) {
                    if (err > 100) {
                        window.toast.warning(
                            `${keys.label}: max error % must be between 0 and 100, or -1 to disable.`,
                        );
                        return;
                    }
                }

                if (!p95Enabled && !p99Enabled && !errEnabled) {
                    // Both targets disabled: allowed.
                    continue;
                }
            }

            const tableType = String(this.config.table_type || '').trim().toUpperCase();
            const isPostgres = tableType === 'POSTGRES';

            if (!isPostgres && !String(this.config.warehouse_name || '').trim()) {
                window.toast.warning('Please select an existing warehouse');
                return;
            }

            const selectedWh = String(this.config.warehouse_name || '').trim().toUpperCase();
            if (!isPostgres && this.resultsWarehouse && selectedWh === this.resultsWarehouse) {
                window.toast.warning(
                    `This template is configured to run on ${selectedWh}, which is also your results warehouse (${this.resultsWarehouse}). Please choose a different warehouse before saving.`,
                );
                return;
            }
            
            this.isSaving = true;
            try {
                const templateData = {
                    template_name: this.config.template_name,
                    description: this.config.description || null,
                    config: this.config
                };
                
                let response;
                if (this.mode === 'edit' && this.loadedTemplate) {
                    // Update existing template
                    response = await fetch(`/api/templates/${this.loadedTemplate.template_id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(templateData)
                    });
                } else {
                    // Create new template
                    response = await fetch('/api/templates/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(templateData)
                    });
                }
                
                if (response.ok) {
                    const createdOrUpdated = await response.json().catch(() => null);
                    const successMessage =
                        this.mode === 'edit'
                            ? 'Template updated successfully.'
                            : 'Template created successfully.';

                    // Keep the user on the configure page (no redirect). Update URL + local state.
                    if (createdOrUpdated && createdOrUpdated.template_id) {
                        this.loadedTemplate = createdOrUpdated;
                        this.hasResults = (createdOrUpdated.usage_count || 0) > 0;

                        // If the template now has results, force view mode. Otherwise edit.
                        if (this.hasResults) {
                            this.mode = 'view';
                            this.isReadOnly = true;
                        } else {
                            this.mode = 'edit';
                            this.isReadOnly = false;
                        }

                        this.config = { ...this.config, ...(createdOrUpdated.config || {}) };
                        this.ensureCanonicalWorkloadConfig();
                        this.config.template_name = createdOrUpdated.template_name;
                        this.config.description = createdOrUpdated.description;
                        this.aiPrepResult = this.aiPrepStatusFromConfig('Loaded from template');
                        this.aiPrepError = null;

                        // Ensure URL has template_id so refresh/reload preserves state.
                        try {
                            const url = new URL(window.location.href);
                            url.searchParams.set('template_id', String(createdOrUpdated.template_id));
                            // Clear mode overrides unless we're explicitly in view mode.
                            if (this.mode === 'view') {
                                url.searchParams.set('mode', 'view');
                            } else {
                                url.searchParams.delete('mode');
                            }
                            window.history.replaceState({}, '', url.pathname + url.search);
                        } catch (e) {
                            console.warn('Failed to update URL after save:', e);
                        }

                        this.snapshotConfig();
                    }

                    if (prepareAfterSave) {
                        // Run preparation immediately after save, and show results in-place.
                        // Defer toast until value pools are complete.
                        await this.prepareAiWorkload();
                        if (this.aiPrepError) {
                            // Template saved, but value pool population failed.
                            window.toast.warning(
                                (this.mode === 'edit' ? 'Template updated' : 'Template created') +
                                    ', but value pool population failed: ' +
                                    this.aiPrepError,
                            );
                        } else {
                            window.toast.success(
                                this.mode === 'edit'
                                    ? 'Template updated and value pools populated.'
                                    : 'Template created and value pools populated.',
                            );
                        }
                    } else {
                        window.toast.success(successMessage);
                    }
                } else {
                    const error = await response.json().catch(() => ({}));
                    const detail = error && error.detail ? error.detail : null;
                    
                    // Check for PgBouncer-related errors and show helpful message with docs link
                    if (detail && (detail.error === 'pgbouncer_extension_missing' || detail.error === 'pgbouncer_privileged_user_not_allowed')) {
                        window.toast.error(detail.message);
                        if (detail.docs_url) {
                            window.toast.info(`See docs: ${detail.docs_url}`, { timeoutMs: 15000 });
                        }
                    } else {
                        window.toast.error(
                            'Error saving template: ' +
                                (detail?.message || detail?.detail || detail || 'Unknown error'),
                        );
                    }
                }
            } catch (error) {
                console.error('Failed to save template:', error);
                window.toast.error('Failed to save template: ' + (error?.message || error));
            } finally {
                this.isSaving = false;
            }
        },

        async reloadTemplate() {
            if (!this.loadedTemplate || !this.loadedTemplate.template_id) return;
            try {
                const resp = await fetch(`/api/templates/${encodeURIComponent(this.loadedTemplate.template_id)}`);
                if (!resp.ok) {
                    return;
                }
                const template = await resp.json();
                this.loadedTemplate = template;
                this.hasResults = (template.usage_count || 0) > 0;
                // Deep merge nested objects to preserve defaults for scaling and guardrails
                const templateConfig = template.config || {};
                const defaultScaling = { ...this.config.scaling };
                const defaultGuardrails = { ...this.config.guardrails };
                this.config = { ...this.config, ...templateConfig };
                this.config.scaling = { ...defaultScaling, ...(templateConfig.scaling || {}) };
                this.config.guardrails = { ...defaultGuardrails, ...(templateConfig.guardrails || {}) };
                // Coerce use_pgbouncer to boolean (default FALSE - PgBouncer may not be available)
                if (this.config.use_pgbouncer == null) {
                    this.config.use_pgbouncer = false;
                } else {
                    const v = String(this.config.use_pgbouncer).trim().toLowerCase();
                    this.config.use_pgbouncer = !['0', 'false', 'no', 'off'].includes(v);
                }
                this.ensureCanonicalWorkloadConfig();
                this.config.template_name = template.template_name;
                this.config.description = template.description;
                this.aiPrepResult = this.aiPrepStatusFromConfig('Loaded from template');
                this.aiPrepError = null;
            } catch (e) {
                console.warn('Failed to reload template:', e);
            }
        },

        async prepareAiWorkload() {
            if (!this.loadedTemplate || !this.loadedTemplate.template_id) {
                window.toast.warning('Save the template first, then run AI preparation.');
                return;
            }
            if (this.hasResults) {
                window.toast.warning(
                    'This template has results and cannot be modified. Copy it first.',
                );
                return;
            }
            this.aiPrepLoading = true;
            this.aiPrepError = null;
            try {
                const resp = await fetch(`/api/templates/${encodeURIComponent(this.loadedTemplate.template_id)}/ai/prepare`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({}),
                });
                const payload = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    const detail = payload && payload.detail ? payload.detail : null;
                    this.aiPrepError =
                        (detail && (detail.message || detail.detail || detail)) ||
                        `Failed (HTTP ${resp.status})`;
                    return;
                }
                this.aiPrepResult = payload;
                // Normalize the response into the same UI shape we use for template-loaded status.
                if (this.aiPrepResult && typeof this.aiPrepResult === 'object') {
                    this.aiPrepResult = {
                        prepared: Boolean(this.aiPrepResult.pool_id),
                        prepared_at: null,
                        pool_id: this.aiPrepResult.pool_id || null,
                        key_column: this.aiPrepResult.key_column || null,
                        time_column: this.aiPrepResult.time_column || null,
                        range_mode: this.aiPrepResult.range_mode || null,
                        pools: this.aiPrepResult.pools || null,
                        cortex_available: Boolean(this.aiPrepResult.ai_available),
                        cortex_error: this.aiPrepResult.ai_error || null,
                    };
                }
                // Reload template config so persisted metadata is reflected locally.
                await this.reloadTemplate();
            } catch (e) {
                this.aiPrepError = e?.message || String(e);
            } finally {
                this.aiPrepLoading = false;
            }
        },

        async prepareTemplate() {
            if (!this.loadedTemplate || !this.loadedTemplate.template_id) {
                window.toast.warning('No template loaded.');
                return;
            }
            if (this.prepareTemplateLoading) return;

            if (this.isDirty()) {
                const proceed = await window.toast.confirm(
                    'You have unsaved changes that will be lost if you run now.',
                    {
                        confirmText: 'Run (discard changes)',
                        cancelText: 'Cancel',
                        confirmVariant: 'warning',
                        timeoutMs: 15000,
                    }
                );
                if (!proceed) return;
            }

            const tableType = String(this.config.table_type || '').toUpperCase();
            const isPostgres = tableType === 'POSTGRES';

            this.prepareTemplateLoading = true;
            try {
                // For Snowflake-executed templates, enforce that the execution warehouse
                // isn't the same as the results warehouse.
                if (!isPostgres) {
                    const infoResp = await fetch('/api/info');
                    const info = infoResp.ok ? await infoResp.json() : {};
                    const resultsWarehouse = String(info.results_warehouse || '').toUpperCase();
                    const execWarehouse = String(this.config.warehouse_name || '').toUpperCase();

                    if (resultsWarehouse && execWarehouse && resultsWarehouse === execWarehouse) {
                        window.toast.warning(
                            `This template is configured to run on ${execWarehouse}, which is also your results warehouse (${resultsWarehouse}). Please edit the template and choose a different warehouse before running.`
                        );
                        return;
                    }
                }

            // Use unified endpoint for all scaling modes (AUTO, BOUNDED, FIXED)
            const endpoint = `/api/tests/from-template/${encodeURIComponent(this.loadedTemplate.template_id)}`;
            const resp = await fetch(endpoint, { method: 'POST' });
                if (!resp.ok) {
                    const err = await resp.json().catch(() => ({}));
                    const detail = err.detail;
                    const errorMsg = typeof detail === 'string' 
                        ? detail 
                        : (detail?.message || detail?.detail || JSON.stringify(detail) || 'Failed to prepare test');
                    throw new Error(errorMsg);
                }
                const data = await resp.json();
                window.location.href = data.dashboard_url || `/dashboard/${data.test_id}`;
            } catch (e) {
                console.error('Failed to prepare template:', e);
                window.toast.error(`Failed to prepare test: ${e.message || e}`);
            } finally {
                this.prepareTemplateLoading = false;
            }
        },

        async aiAdjustCustomSql() {
            // Preview-only: updates the 4 custom SQL statements + %s in the UI.
            // No DB writes occur until the user saves the template.
            if (!this.hasSelectedTable()) {
                window.toast.warning('Select database, schema, and table first.');
                return;
            }
            this.aiSqlAdjustLoading = true;
            try {
                const resp = await fetch('/api/templates/ai/adjust-sql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ config: this.config }),
                });
                const payload = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    const detail = payload && payload.detail ? payload.detail : null;
                    window.toast.error(
                        'AI SQL adjustment failed: ' +
                            (detail?.message || detail?.detail || detail || `HTTP ${resp.status}`),
                    );
                    return;
                }

                const level = String(payload.toast_level || 'success').toLowerCase();
                const shouldApplyMix = level === 'warning';

                // Store Interactive Table metadata
                this.interactiveTableClusterBy = payload.cluster_by || null;
                this.interactiveTableWarnings = payload.warnings || [];

                // Apply adjustments locally
                this.config.workload_type = 'CUSTOM';
                this.config.custom_point_lookup_query = payload.custom_point_lookup_query || '';
                this.config.custom_range_scan_query = payload.custom_range_scan_query || '';
                this.config.custom_insert_query = payload.custom_insert_query || '';
                this.config.custom_update_query = payload.custom_update_query || '';
                if (shouldApplyMix) {
                    this.config.custom_point_lookup_pct = Number(payload.custom_point_lookup_pct || 0);
                    this.config.custom_range_scan_pct = Number(payload.custom_range_scan_pct || 0);
                    this.config.custom_insert_pct = Number(payload.custom_insert_pct || 0);
                    this.config.custom_update_pct = Number(payload.custom_update_pct || 0);
                }

                // Store column map + ai_workload metadata in config (will persist on save).
                if (payload.columns) {
                    this.config.columns = payload.columns;
                }
                // IMPORTANT: do not clobber prepared pool metadata (pool_id/columns). Only
                // store ai_workload hints if the template is not already prepared.
                if (payload.ai_workload) {
                    const existing = this.config.ai_workload;
                    const isPrepared = existing && typeof existing === 'object' && existing.pool_id;
                    if (!isPrepared) {
                        this.config.ai_workload = payload.ai_workload;
                    }
                }
                if (shouldApplyMix) {
                    this.syncMixPresetFromWeights();
                }

                // Toast only when unexpected (i.e., we had to disable an operation + redistribute mix).
                if (level === 'warning') {
                    const summary = payload.summary || 'SQL generated with issues.';
                    window.toast.warning(summary);
                }

                // Show Interactive Table warnings (each as a separate warning toast)
                if (this.interactiveTableWarnings && this.interactiveTableWarnings.length > 0) {
                    for (const warning of this.interactiveTableWarnings) {
                        window.toast.warning(warning, { duration: 10000 });
                    }
                }
            } catch (e) {
                window.toast.error('AI SQL adjustment failed: ' + (e?.message || e));
            } finally {
                this.aiSqlAdjustLoading = false;
            }
        },
        
        cancel() {
            window.location.href = '/templates';
        },
        
        async copyTemplate() {
            if (!this.loadedTemplate || this.copyTemplateLoading) return;
            
            this.copyTemplateLoading = true;
            const newTemplate = {
                ...this.loadedTemplate,
                template_name: this.loadedTemplate.template_name + ' (Copy)',
                template_id: undefined,
                created_at: undefined,
                updated_at: undefined,
                usage_count: 0
            };
            
            try {
                const response = await fetch('/api/templates/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newTemplate)
                });
                
                if (response.ok) {
                    const created = await response.json().catch(() => null);
                    if (created && created.template_id) {
                        window.toast.queueNext('success', 'Template copied successfully.');
                        // Open the newly created template in editable mode (your choice A).
                        window.location.href = `/configure?template_id=${encodeURIComponent(created.template_id)}`;
                        return;
                    }
                    window.toast.queueNext('success', 'Template copied successfully.');
                    window.location.href = '/templates';
                } else {
                    window.toast.error('Failed to copy template');
                }
            } catch (error) {
                console.error('Error copying template:', error);
                window.toast.error('Error copying template');
            } finally {
                this.copyTemplateLoading = false;
            }
        },
        
        async deleteTemplateWithResults() {
            if (!this.loadedTemplate) return;
            
            const confirmMsg = `Delete "${this.loadedTemplate.template_name}" and all ${this.loadedTemplate.usage_count} test results? This cannot be undone.`;
            const confirmed = await window.toast.confirm(confirmMsg, {
                confirmText: 'Delete',
                confirmVariant: 'danger',
                timeoutMs: 10_000,
            });
            if (!confirmed) {
                return;
            }
            
            this.deleteTemplateLoading = true;
            try {
                const response = await fetch(`/api/templates/${this.loadedTemplate.template_id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    window.toast.queueNext('success', 'Template and results deleted.');
                    window.location.href = '/templates';
                } else {
                    window.toast.error('Failed to delete template');
                }
            } catch (error) {
                console.error('Error deleting template:', error);
                window.toast.error('Error deleting template');
            } finally {
                this.deleteTemplateLoading = false;
            }
        },
        
        async resetConfig() {
            const confirmed = await window.toast.confirm('Reset all configuration?', {
                confirmText: 'Reset',
                confirmVariant: 'primary',
                timeoutMs: 10_000,
            });
            if (confirmed) {
                this.config = {
                    table_type: 'STANDARD',
                    database: '{{ default_database }}',
                    schema: 'PUBLIC',
                    table_name: '',
                    warehouse_name: '',
                    warehouse_size: 'MEDIUM',
                    multi_cluster: false,
                    min_clusters: 1,
                    max_clusters: 3,
                    scaling_policy: 'STANDARD',
                    duration: 300,
                    load_mode: 'CONCURRENCY',
                    target_qps: 100,
                    starting_threads: null,
                    max_thread_increase: 15,
                    scaling: {
                        mode: 'AUTO',
                        min_connections: 5,
                    },
                    guardrails: {
                        max_cpu_percent: 80,
                        max_memory_percent: 85,
                    },
                    concurrent_connections: 10,
                    start_concurrency: 5,
                    concurrency_increment: 10,
                    step_duration_seconds: 30,
                    qps_stability_pct: 5.0,
                    latency_stability_pct: 20.0,
                    max_error_rate_pct: 1.0,
                    workload_type: 'CUSTOM',
                    mix_preset: 'MIXED',
                    think_time: 0,
                    warmup: 30,
                    custom_point_lookup_query: 'SELECT * FROM {table} WHERE id = ?',
                    custom_range_scan_query:
                        'SELECT * FROM {table} WHERE id BETWEEN ? AND ? + 100 ORDER BY id LIMIT 100',
                    custom_insert_query:
                        'INSERT INTO {table} (id, data, timestamp) VALUES (?, ?, CURRENT_TIMESTAMP)',
                    custom_update_query:
                        'UPDATE {table} SET data = ?, timestamp = CURRENT_TIMESTAMP WHERE id = ?',
                    custom_point_lookup_pct: 25,
                    custom_range_scan_pct: 25,
                    custom_insert_pct: 35,
                    custom_update_pct: 15,
                    // Per-query-type targets (SLOs). Use -1 to disable a target.
                    target_point_lookup_p95_latency_ms: -1,
                    target_range_scan_p95_latency_ms: -1,
                    target_insert_p95_latency_ms: -1,
                    target_update_p95_latency_ms: -1,
                    target_point_lookup_p99_latency_ms: -1,
                    target_range_scan_p99_latency_ms: -1,
                    target_insert_p99_latency_ms: -1,
                    target_update_p99_latency_ms: -1,
                    target_point_lookup_error_rate_pct: -1,
                    target_range_scan_error_rate_pct: -1,
                    target_insert_error_rate_pct: -1,
                    target_update_error_rate_pct: -1,
                    test_name: '',
                    description: '',
                    save_as_template: false,
                    template_name: '',
                    template_description: ''
                };
                await this.loadCatalog();
            }
        }
    };
}
</script>
{% endblock %}
